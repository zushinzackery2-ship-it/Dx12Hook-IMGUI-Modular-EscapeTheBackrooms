#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Backrooms

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum Backrooms.EFancyInputDevice
// NumValues: 0x0005
enum class EFancyInputDevice : uint8
{
	KeyboardMouse                            = 0,
	Gamepad                                  = 1,
	Oculus                                   = 2,
	HTCVive                                  = 3,
	EFancyInputDevice_MAX                    = 4,
};

// Enum Backrooms.EOnlineStatus
// NumValues: 0x0003
enum class EOnlineStatus : uint8
{
	Offline                                  = 0,
	Online                                   = 1,
	EOnlineStatus_MAX                        = 2,
};

// Enum Backrooms.EEstablishUserReason
// NumValues: 0x0007
enum class EEstablishUserReason : uint8
{
	NONE                                     = 0,
	INITIAL_USER                             = 1,
	USER_WAS_INVALID                         = 2,
	CTRL_DISCONNECTED                        = 3,
	SIGNED_OUT                               = 4,
	REQUESTED                                = 5,
	EEstablishUserReason_MAX                 = 6,
};

// Enum Backrooms.EMotionComponentType
// NumValues: 0x0004
enum class EMotionComponentType : uint8
{
	TARGET                                   = 0,
	TEAMMATE                                 = 1,
	SCANNER                                  = 2,
	EMotionComponentType_MAX                 = 3,
};

// Enum Backrooms.EAimAssistCastType
// NumValues: 0x0003
enum class EAimAssistCastType : uint8
{
	Sphere                                   = 0,
	Cone                                     = 1,
	EAimAssistCastType_MAX                   = 2,
};

// Enum Backrooms.ECollisionSelectionMethod
// NumValues: 0x0003
enum class ECollisionSelectionMethod : uint8
{
	UseCollisionChannel                      = 0,
	UseCollisionProfile                      = 1,
	ECollisionSelectionMethod_MAX            = 2,
};

// Enum Backrooms.EArmVisibility
// NumValues: 0x0003
enum class EArmVisibility : uint8
{
	Right                                    = 0,
	Both                                     = 1,
	EArmVisibility_MAX                       = 2,
};

// Enum Backrooms.EEventType
// NumValues: 0x0004
enum class EEventType : uint8
{
	None                                     = 0,
	Halloween                                = 1,
	Christmas                                = 2,
	EEventType_MAX                           = 3,
};

// Enum Backrooms.ActivityCompletionStatus
// NumValues: 0x0004
enum class EActivityCompletionStatus : uint8
{
	ActivityCompleted                        = 0,
	ActivityFailed                           = 1,
	ActivityCancelled                        = 2,
	ActivityCompletionStatus_MAX             = 3,
};

// Enum Backrooms.EVRVelocityType
// NumValues: 0x0004
enum class EVRVelocityType : uint8
{
	VRLOCITY_Default                         = 0,
	VRLOCITY_RunningAverage                  = 1,
	VRLOCITY_SamplePeak                      = 2,
	VRLOCITY_MAX                             = 3,
};

// Enum Backrooms.EVRRotationQuantization
// NumValues: 0x0003
enum class EVRRotationQuantization : uint8
{
	RoundTo10Bits                            = 0,
	RoundToShort                             = 1,
	EVRRotationQuantization_MAX              = 2,
};

// Enum Backrooms.EVRVectorQuantization
// NumValues: 0x0003
enum class EVRVectorQuantization : uint8
{
	RoundOneDecimal                          = 0,
	RoundTwoDecimals                         = 1,
	EVRVectorQuantization_MAX                = 2,
};

// Enum Backrooms.EItemTypes
// NumValues: 0x0003
enum class EItemTypes : uint8
{
	TOOL                                     = 0,
	CONSUMABLE                               = 1,
	EItemTypes_MAX                           = 2,
};

// Enum Backrooms.EItemRarity
// NumValues: 0x0007
enum class EItemRarity : uint8
{
	Undefined                                = 0,
	Common                                   = 1,
	Uncommon                                 = 2,
	Rare                                     = 3,
	Epic                                     = 4,
	Legendary                                = 5,
	EItemRarity_MAX                          = 6,
};

// Enum Backrooms.EItemType
// NumValues: 0x0006
enum class EItemType : uint8
{
	Undefined                                = 0,
	Placeable                                = 1,
	Equipment                                = 2,
	Consumable                               = 3,
	Material                                 = 4,
	EItemType_MAX                            = 5,
};

// Enum Backrooms.EGizmoType
// NumValues: 0x0005
enum class EGizmoType : uint8
{
	None                                     = 0,
	Location                                 = 1,
	Rotation                                 = 2,
	Scale                                    = 3,
	EGizmoType_MAX                           = 4,
};

// Enum Backrooms.EScaleAxis
// NumValues: 0x0005
enum class EScaleAxis : uint8
{
	None                                     = 0,
	ScaleX                                   = 1,
	ScaleY                                   = 2,
	ScaleZ                                   = 3,
	EScaleAxis_MAX                           = 4,
};

// Enum Backrooms.ERotationAxis
// NumValues: 0x0005
enum class ERotationAxis : uint8
{
	None                                     = 0,
	Yaw                                      = 1,
	Roll                                     = 2,
	Pitch                                    = 3,
	ERotationAxis_MAX                        = 4,
};

// Enum Backrooms.EMoveAxis
// NumValues: 0x0005
enum class EMoveAxis : uint8
{
	None                                     = 0,
	XAxis                                    = 1,
	YAxis                                    = 2,
	ZAxis                                    = 3,
	EMoveAxis_MAX                            = 4,
};

// ScriptStruct Backrooms.VoteParameters
// 0x000C (0x000C - 0x0000)
struct FVoteParameters final
{
public:
	int32                                         VotingPlayers;                                     // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnanimousVote;                                  // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoteParameters) == 0x000004, "Wrong alignment on FVoteParameters");
static_assert(sizeof(FVoteParameters) == 0x00000C, "Wrong size on FVoteParameters");
static_assert(offsetof(FVoteParameters, VotingPlayers) == 0x000000, "Member 'FVoteParameters::VotingPlayers' has a wrong offset!");
static_assert(offsetof(FVoteParameters, Duration) == 0x000004, "Member 'FVoteParameters::Duration' has a wrong offset!");
static_assert(offsetof(FVoteParameters, bIsUnanimousVote) == 0x000008, "Member 'FVoteParameters::bIsUnanimousVote' has a wrong offset!");

// ScriptStruct Backrooms.RadarTargetStruct
// 0x0018 (0x0018 - 0x0000)
struct FRadarTargetStruct final
{
public:
	class URadarPlayerComponent*                  Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeammate;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadarTargetStruct) == 0x000008, "Wrong alignment on FRadarTargetStruct");
static_assert(sizeof(FRadarTargetStruct) == 0x000018, "Wrong size on FRadarTargetStruct");
static_assert(offsetof(FRadarTargetStruct, Target) == 0x000000, "Member 'FRadarTargetStruct::Target' has a wrong offset!");
static_assert(offsetof(FRadarTargetStruct, Distance) == 0x000008, "Member 'FRadarTargetStruct::Distance' has a wrong offset!");
static_assert(offsetof(FRadarTargetStruct, Velocity) == 0x00000C, "Member 'FRadarTargetStruct::Velocity' has a wrong offset!");
static_assert(offsetof(FRadarTargetStruct, IsTeammate) == 0x000010, "Member 'FRadarTargetStruct::IsTeammate' has a wrong offset!");

// ScriptStruct Backrooms.MapEditorItem
// 0x0050 (0x0050 - 0x0000)
struct FMapEditorItem final
{
public:
	TSubclassOf<class AActor>                     ActorToSpawn;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ItemTransform;                                     // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEditorItem) == 0x000010, "Wrong alignment on FMapEditorItem");
static_assert(sizeof(FMapEditorItem) == 0x000050, "Wrong size on FMapEditorItem");
static_assert(offsetof(FMapEditorItem, ActorToSpawn) == 0x000000, "Member 'FMapEditorItem::ActorToSpawn' has a wrong offset!");
static_assert(offsetof(FMapEditorItem, ItemTransform) == 0x000010, "Member 'FMapEditorItem::ItemTransform' has a wrong offset!");
static_assert(offsetof(FMapEditorItem, Materials) == 0x000040, "Member 'FMapEditorItem::Materials' has a wrong offset!");

// ScriptStruct Backrooms.TargetsStruct
// 0x0018 (0x0018 - 0x0000)
struct FTargetsStruct final
{
public:
	class UMotionScannerComponent*                Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeammate;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetsStruct) == 0x000008, "Wrong alignment on FTargetsStruct");
static_assert(sizeof(FTargetsStruct) == 0x000018, "Wrong size on FTargetsStruct");
static_assert(offsetof(FTargetsStruct, Target) == 0x000000, "Member 'FTargetsStruct::Target' has a wrong offset!");
static_assert(offsetof(FTargetsStruct, Distance) == 0x000008, "Member 'FTargetsStruct::Distance' has a wrong offset!");
static_assert(offsetof(FTargetsStruct, Velocity) == 0x00000C, "Member 'FTargetsStruct::Velocity' has a wrong offset!");
static_assert(offsetof(FTargetsStruct, IsTeammate) == 0x000010, "Member 'FTargetsStruct::IsTeammate' has a wrong offset!");

// ScriptStruct Backrooms.VoteData
// 0x0068 (0x0068 - 0x0000)
struct FVoteData final
{
public:
	int32                                         VotingPlayers;                                     // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnanimousVote;                                  // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class APlayerState*, bool>               PlayerVotingMap;                                   // 0x0008(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoteData) == 0x000008, "Wrong alignment on FVoteData");
static_assert(sizeof(FVoteData) == 0x000068, "Wrong size on FVoteData");
static_assert(offsetof(FVoteData, VotingPlayers) == 0x000000, "Member 'FVoteData::VotingPlayers' has a wrong offset!");
static_assert(offsetof(FVoteData, bIsUnanimousVote) == 0x000004, "Member 'FVoteData::bIsUnanimousVote' has a wrong offset!");
static_assert(offsetof(FVoteData, PlayerVotingMap) == 0x000008, "Member 'FVoteData::PlayerVotingMap' has a wrong offset!");
static_assert(offsetof(FVoteData, Duration) == 0x000058, "Member 'FVoteData::Duration' has a wrong offset!");
static_assert(offsetof(FVoteData, CurrentTime) == 0x00005C, "Member 'FVoteData::CurrentTime' has a wrong offset!");
static_assert(offsetof(FVoteData, IsActive) == 0x000060, "Member 'FVoteData::IsActive' has a wrong offset!");

// ScriptStruct Backrooms.AimAssistTarget
// 0x0038 (0x0038 - 0x0000)
struct FAimAssistTarget final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComponentExtent;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocation;                                     // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimAssistTarget) == 0x000008, "Wrong alignment on FAimAssistTarget");
static_assert(sizeof(FAimAssistTarget) == 0x000038, "Wrong size on FAimAssistTarget");
static_assert(offsetof(FAimAssistTarget, HitActor) == 0x000000, "Member 'FAimAssistTarget::HitActor' has a wrong offset!");
static_assert(offsetof(FAimAssistTarget, ComponentExtent) == 0x000008, "Member 'FAimAssistTarget::ComponentExtent' has a wrong offset!");
static_assert(offsetof(FAimAssistTarget, Location) == 0x00000C, "Member 'FAimAssistTarget::Location' has a wrong offset!");
static_assert(offsetof(FAimAssistTarget, ActorLocation) == 0x000018, "Member 'FAimAssistTarget::ActorLocation' has a wrong offset!");
static_assert(offsetof(FAimAssistTarget, Velocity) == 0x000024, "Member 'FAimAssistTarget::Velocity' has a wrong offset!");
static_assert(offsetof(FAimAssistTarget, Tag) == 0x000030, "Member 'FAimAssistTarget::Tag' has a wrong offset!");

// ScriptStruct Backrooms.TelemetryStruct
// 0x0008 (0x0008 - 0x0000)
struct FTelemetryStruct final
{
public:
	float                                         MinDistance;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetsCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTelemetryStruct) == 0x000004, "Wrong alignment on FTelemetryStruct");
static_assert(sizeof(FTelemetryStruct) == 0x000008, "Wrong size on FTelemetryStruct");
static_assert(offsetof(FTelemetryStruct, MinDistance) == 0x000000, "Member 'FTelemetryStruct::MinDistance' has a wrong offset!");
static_assert(offsetof(FTelemetryStruct, TargetsCount) == 0x000004, "Member 'FTelemetryStruct::TargetsCount' has a wrong offset!");

// ScriptStruct Backrooms.ScannerStruct
// 0x0020 (0x0020 - 0x0000)
struct FScannerStruct final
{
public:
	float                                         ScanRate;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanDistance;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedDetected;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDetectOffset;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWavePosition;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMultiply;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WavePositionUI;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveDistance;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScannerStruct) == 0x000004, "Wrong alignment on FScannerStruct");
static_assert(sizeof(FScannerStruct) == 0x000020, "Wrong size on FScannerStruct");
static_assert(offsetof(FScannerStruct, ScanRate) == 0x000000, "Member 'FScannerStruct::ScanRate' has a wrong offset!");
static_assert(offsetof(FScannerStruct, ScanDistance) == 0x000004, "Member 'FScannerStruct::ScanDistance' has a wrong offset!");
static_assert(offsetof(FScannerStruct, MinSpeedDetected) == 0x000008, "Member 'FScannerStruct::MinSpeedDetected' has a wrong offset!");
static_assert(offsetof(FScannerStruct, TargetDetectOffset) == 0x00000C, "Member 'FScannerStruct::TargetDetectOffset' has a wrong offset!");
static_assert(offsetof(FScannerStruct, MaxWavePosition) == 0x000010, "Member 'FScannerStruct::MaxWavePosition' has a wrong offset!");
static_assert(offsetof(FScannerStruct, WaveMultiply) == 0x000014, "Member 'FScannerStruct::WaveMultiply' has a wrong offset!");
static_assert(offsetof(FScannerStruct, WavePositionUI) == 0x000018, "Member 'FScannerStruct::WavePositionUI' has a wrong offset!");
static_assert(offsetof(FScannerStruct, WaveDistance) == 0x00001C, "Member 'FScannerStruct::WaveDistance' has a wrong offset!");

// ScriptStruct Backrooms.MissionStructure
// 0x0058 (0x0060 - 0x0008)
struct FMissionStructure final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DangerClass;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPEarned;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPPenalty;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCompleted;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CompletedInTime;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerDeaths;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntitySightings;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowSanityMoments;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExtraDataRowName;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionStructure) == 0x000008, "Wrong alignment on FMissionStructure");
static_assert(sizeof(FMissionStructure) == 0x000060, "Wrong size on FMissionStructure");
static_assert(offsetof(FMissionStructure, Name) == 0x000008, "Member 'FMissionStructure::Name' has a wrong offset!");
static_assert(offsetof(FMissionStructure, Description) == 0x000010, "Member 'FMissionStructure::Description' has a wrong offset!");
static_assert(offsetof(FMissionStructure, Image) == 0x000028, "Member 'FMissionStructure::Image' has a wrong offset!");
static_assert(offsetof(FMissionStructure, DangerClass) == 0x000030, "Member 'FMissionStructure::DangerClass' has a wrong offset!");
static_assert(offsetof(FMissionStructure, XPEarned) == 0x000034, "Member 'FMissionStructure::XPEarned' has a wrong offset!");
static_assert(offsetof(FMissionStructure, XPPenalty) == 0x000038, "Member 'FMissionStructure::XPPenalty' has a wrong offset!");
static_assert(offsetof(FMissionStructure, TimeCompleted) == 0x00003C, "Member 'FMissionStructure::TimeCompleted' has a wrong offset!");
static_assert(offsetof(FMissionStructure, CompletedInTime) == 0x000040, "Member 'FMissionStructure::CompletedInTime' has a wrong offset!");
static_assert(offsetof(FMissionStructure, PlayerDeaths) == 0x000044, "Member 'FMissionStructure::PlayerDeaths' has a wrong offset!");
static_assert(offsetof(FMissionStructure, EntitySightings) == 0x000048, "Member 'FMissionStructure::EntitySightings' has a wrong offset!");
static_assert(offsetof(FMissionStructure, LowSanityMoments) == 0x00004C, "Member 'FMissionStructure::LowSanityMoments' has a wrong offset!");
static_assert(offsetof(FMissionStructure, ExtraDataRowName) == 0x000050, "Member 'FMissionStructure::ExtraDataRowName' has a wrong offset!");

// ScriptStruct Backrooms.TargetStruct
// 0x0018 (0x0018 - 0x0000)
struct FTargetStruct final
{
public:
	class UStaticMesh*                            TargetStaticMesh;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TargetMaterial;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeScale;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetStruct) == 0x000008, "Wrong alignment on FTargetStruct");
static_assert(sizeof(FTargetStruct) == 0x000018, "Wrong size on FTargetStruct");
static_assert(offsetof(FTargetStruct, TargetStaticMesh) == 0x000000, "Member 'FTargetStruct::TargetStaticMesh' has a wrong offset!");
static_assert(offsetof(FTargetStruct, TargetMaterial) == 0x000008, "Member 'FTargetStruct::TargetMaterial' has a wrong offset!");
static_assert(offsetof(FTargetStruct, SizeScale) == 0x000010, "Member 'FTargetStruct::SizeScale' has a wrong offset!");

// ScriptStruct Backrooms.AimAssistSettings
// 0x0014 (0x0014 - 0x0000)
struct FAimAssistSettings final
{
public:
	float                                         HorizontalSmoothnessAwayFromTarget;                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSmoothnessTowardsTarget;                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSmoothnessGranularity;                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalCompensation;                             // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalSmoothness;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimAssistSettings) == 0x000004, "Wrong alignment on FAimAssistSettings");
static_assert(sizeof(FAimAssistSettings) == 0x000014, "Wrong size on FAimAssistSettings");
static_assert(offsetof(FAimAssistSettings, HorizontalSmoothnessAwayFromTarget) == 0x000000, "Member 'FAimAssistSettings::HorizontalSmoothnessAwayFromTarget' has a wrong offset!");
static_assert(offsetof(FAimAssistSettings, HorizontalSmoothnessTowardsTarget) == 0x000004, "Member 'FAimAssistSettings::HorizontalSmoothnessTowardsTarget' has a wrong offset!");
static_assert(offsetof(FAimAssistSettings, HorizontalSmoothnessGranularity) == 0x000008, "Member 'FAimAssistSettings::HorizontalSmoothnessGranularity' has a wrong offset!");
static_assert(offsetof(FAimAssistSettings, bVerticalCompensation) == 0x00000C, "Member 'FAimAssistSettings::bVerticalCompensation' has a wrong offset!");
static_assert(offsetof(FAimAssistSettings, VerticalSmoothness) == 0x000010, "Member 'FAimAssistSettings::VerticalSmoothness' has a wrong offset!");

// ScriptStruct Backrooms.Collectible
// 0x0038 (0x0040 - 0x0008)
struct FCollectible final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectible) == 0x000008, "Wrong alignment on FCollectible");
static_assert(sizeof(FCollectible) == 0x000040, "Wrong size on FCollectible");
static_assert(offsetof(FCollectible, ID) == 0x000008, "Member 'FCollectible::ID' has a wrong offset!");
static_assert(offsetof(FCollectible, Name) == 0x000010, "Member 'FCollectible::Name' has a wrong offset!");
static_assert(offsetof(FCollectible, Description) == 0x000028, "Member 'FCollectible::Description' has a wrong offset!");
static_assert(offsetof(FCollectible, Quantity) == 0x000030, "Member 'FCollectible::Quantity' has a wrong offset!");
static_assert(offsetof(FCollectible, Icon) == 0x000038, "Member 'FCollectible::Icon' has a wrong offset!");

// ScriptStruct Backrooms.QueuedSaveGame
// 0x0020 (0x0020 - 0x0000)
struct FQueuedSaveGame final
{
public:
	class USaveGame*                              SaveGameObject;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueuedSaveGame) == 0x000008, "Wrong alignment on FQueuedSaveGame");
static_assert(sizeof(FQueuedSaveGame) == 0x000020, "Wrong size on FQueuedSaveGame");
static_assert(offsetof(FQueuedSaveGame, SaveGameObject) == 0x000000, "Member 'FQueuedSaveGame::SaveGameObject' has a wrong offset!");

// ScriptStruct Backrooms.BPVRComponentPosRep
// 0x001C (0x001C - 0x0000)
struct FBPVRComponentPosRep final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EVRVectorQuantization                         QuantizationLevel;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVRRotationQuantization                       RotationQuantizationLevel;                         // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBPVRComponentPosRep) == 0x000004, "Wrong alignment on FBPVRComponentPosRep");
static_assert(sizeof(FBPVRComponentPosRep) == 0x00001C, "Wrong size on FBPVRComponentPosRep");
static_assert(offsetof(FBPVRComponentPosRep, Position) == 0x000000, "Member 'FBPVRComponentPosRep::Position' has a wrong offset!");
static_assert(offsetof(FBPVRComponentPosRep, Rotation) == 0x00000C, "Member 'FBPVRComponentPosRep::Rotation' has a wrong offset!");
static_assert(offsetof(FBPVRComponentPosRep, QuantizationLevel) == 0x000018, "Member 'FBPVRComponentPosRep::QuantizationLevel' has a wrong offset!");
static_assert(offsetof(FBPVRComponentPosRep, RotationQuantizationLevel) == 0x000019, "Member 'FBPVRComponentPosRep::RotationQuantizationLevel' has a wrong offset!");

// ScriptStruct Backrooms.BPLowPassPeakFilter
// 0x0020 (0x0020 - 0x0000)
struct FBPLowPassPeakFilter final
{
public:
	int32                                         VelocitySamples;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        VelocitySampleLog;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBPLowPassPeakFilter) == 0x000008, "Wrong alignment on FBPLowPassPeakFilter");
static_assert(sizeof(FBPLowPassPeakFilter) == 0x000020, "Wrong size on FBPLowPassPeakFilter");
static_assert(offsetof(FBPLowPassPeakFilter, VelocitySamples) == 0x000000, "Member 'FBPLowPassPeakFilter::VelocitySamples' has a wrong offset!");
static_assert(offsetof(FBPLowPassPeakFilter, VelocitySampleLog) == 0x000008, "Member 'FBPLowPassPeakFilter::VelocitySampleLog' has a wrong offset!");

// ScriptStruct Backrooms.BPEuroLowPassFilterTrans
// 0x0150 (0x0150 - 0x0000)
struct alignas(0x10) FBPEuroLowPassFilterTrans final
{
public:
	float                                         MinCutoff;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaCutoff;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutoffSlope;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x144];                                      // 0x000C(0x0144)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBPEuroLowPassFilterTrans) == 0x000010, "Wrong alignment on FBPEuroLowPassFilterTrans");
static_assert(sizeof(FBPEuroLowPassFilterTrans) == 0x000150, "Wrong size on FBPEuroLowPassFilterTrans");
static_assert(offsetof(FBPEuroLowPassFilterTrans, MinCutoff) == 0x000000, "Member 'FBPEuroLowPassFilterTrans::MinCutoff' has a wrong offset!");
static_assert(offsetof(FBPEuroLowPassFilterTrans, DeltaCutoff) == 0x000004, "Member 'FBPEuroLowPassFilterTrans::DeltaCutoff' has a wrong offset!");
static_assert(offsetof(FBPEuroLowPassFilterTrans, CutoffSlope) == 0x000008, "Member 'FBPEuroLowPassFilterTrans::CutoffSlope' has a wrong offset!");

// ScriptStruct Backrooms.ItemQuality
// 0x0001 (0x0001 - 0x0000)
struct FItemQuality final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemQuality) == 0x000001, "Wrong alignment on FItemQuality");
static_assert(sizeof(FItemQuality) == 0x000001, "Wrong size on FItemQuality");

// ScriptStruct Backrooms.ItemStructure
// 0x0060 (0x0068 - 0x0008)
struct FItemStructure final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Quality;                                           // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PriceValue;                                        // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackable;                                       // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxStackSize;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 Class;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AInspectableActor>          InspectableClass;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDroppable;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ItemMesh;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DroppedMesh;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemStructure) == 0x000008, "Wrong alignment on FItemStructure");
static_assert(sizeof(FItemStructure) == 0x000068, "Wrong size on FItemStructure");
static_assert(offsetof(FItemStructure, ID) == 0x000008, "Member 'FItemStructure::ID' has a wrong offset!");
static_assert(offsetof(FItemStructure, Icon) == 0x000010, "Member 'FItemStructure::Icon' has a wrong offset!");
static_assert(offsetof(FItemStructure, Name) == 0x000018, "Member 'FItemStructure::Name' has a wrong offset!");
static_assert(offsetof(FItemStructure, Description) == 0x000030, "Member 'FItemStructure::Description' has a wrong offset!");
static_assert(offsetof(FItemStructure, ItemType) == 0x000038, "Member 'FItemStructure::ItemType' has a wrong offset!");
static_assert(offsetof(FItemStructure, Quality) == 0x000039, "Member 'FItemStructure::Quality' has a wrong offset!");
static_assert(offsetof(FItemStructure, PriceValue) == 0x00003A, "Member 'FItemStructure::PriceValue' has a wrong offset!");
static_assert(offsetof(FItemStructure, IsStackable) == 0x00003B, "Member 'FItemStructure::IsStackable' has a wrong offset!");
static_assert(offsetof(FItemStructure, MaxStackSize) == 0x00003C, "Member 'FItemStructure::MaxStackSize' has a wrong offset!");
static_assert(offsetof(FItemStructure, Class) == 0x000040, "Member 'FItemStructure::Class' has a wrong offset!");
static_assert(offsetof(FItemStructure, InspectableClass) == 0x000048, "Member 'FItemStructure::InspectableClass' has a wrong offset!");
static_assert(offsetof(FItemStructure, IsDroppable) == 0x000050, "Member 'FItemStructure::IsDroppable' has a wrong offset!");
static_assert(offsetof(FItemStructure, ItemMesh) == 0x000058, "Member 'FItemStructure::ItemMesh' has a wrong offset!");
static_assert(offsetof(FItemStructure, DroppedMesh) == 0x000060, "Member 'FItemStructure::DroppedMesh' has a wrong offset!");

// ScriptStruct Backrooms.LIDARDotStruct
// 0x0010 (0x0010 - 0x0000)
struct FLIDARDotStruct final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         timestamp;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLIDARDotStruct) == 0x000008, "Wrong alignment on FLIDARDotStruct");
static_assert(sizeof(FLIDARDotStruct) == 0x000010, "Wrong size on FLIDARDotStruct");
static_assert(offsetof(FLIDARDotStruct, RenderTarget) == 0x000000, "Member 'FLIDARDotStruct::RenderTarget' has a wrong offset!");
static_assert(offsetof(FLIDARDotStruct, timestamp) == 0x000008, "Member 'FLIDARDotStruct::timestamp' has a wrong offset!");

// ScriptStruct Backrooms.MapEditorItems
// 0x0010 (0x0010 - 0x0000)
struct FMapEditorItems final
{
public:
	TArray<struct FMapEditorItem>                 Items;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEditorItems) == 0x000008, "Wrong alignment on FMapEditorItems");
static_assert(sizeof(FMapEditorItems) == 0x000010, "Wrong size on FMapEditorItems");
static_assert(offsetof(FMapEditorItems, Items) == 0x000000, "Member 'FMapEditorItems::Items' has a wrong offset!");

// ScriptStruct Backrooms.MapEditorItemMaterial
// 0x0020 (0x0020 - 0x0000)
struct FMapEditorItemMaterial final
{
public:
	TArray<class UMeshComponent*>                 MeshComponents;                                    // 0x0000(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEditorItemMaterial) == 0x000008, "Wrong alignment on FMapEditorItemMaterial");
static_assert(sizeof(FMapEditorItemMaterial) == 0x000020, "Wrong size on FMapEditorItemMaterial");
static_assert(offsetof(FMapEditorItemMaterial, MeshComponents) == 0x000000, "Member 'FMapEditorItemMaterial::MeshComponents' has a wrong offset!");
static_assert(offsetof(FMapEditorItemMaterial, Materials) == 0x000010, "Member 'FMapEditorItemMaterial::Materials' has a wrong offset!");

// ScriptStruct Backrooms.MapEditorSteps
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMapEditorSteps final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapEditorSteps) == 0x000008, "Wrong alignment on FMapEditorSteps");
static_assert(sizeof(FMapEditorSteps) == 0x000018, "Wrong size on FMapEditorSteps");

// ScriptStruct Backrooms.MapEditorSnapping
// 0x000C (0x000C - 0x0000)
struct FMapEditorSnapping final
{
public:
	float                                         Location;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEditorSnapping) == 0x000004, "Wrong alignment on FMapEditorSnapping");
static_assert(sizeof(FMapEditorSnapping) == 0x00000C, "Wrong size on FMapEditorSnapping");
static_assert(offsetof(FMapEditorSnapping, Location) == 0x000000, "Member 'FMapEditorSnapping::Location' has a wrong offset!");
static_assert(offsetof(FMapEditorSnapping, Rotation) == 0x000004, "Member 'FMapEditorSnapping::Rotation' has a wrong offset!");
static_assert(offsetof(FMapEditorSnapping, Scale) == 0x000008, "Member 'FMapEditorSnapping::Scale' has a wrong offset!");

// ScriptStruct Backrooms.ProfaneWord
// 0x0020 (0x0028 - 0x0008)
struct FProfaneWord final : public FTableRowBase
{
public:
	class FName                                   Language;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Severity;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Word;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProfaneWord) == 0x000008, "Wrong alignment on FProfaneWord");
static_assert(sizeof(FProfaneWord) == 0x000028, "Wrong size on FProfaneWord");
static_assert(offsetof(FProfaneWord, Language) == 0x000008, "Member 'FProfaneWord::Language' has a wrong offset!");
static_assert(offsetof(FProfaneWord, Severity) == 0x000010, "Member 'FProfaneWord::Severity' has a wrong offset!");
static_assert(offsetof(FProfaneWord, Word) == 0x000018, "Member 'FProfaneWord::Word' has a wrong offset!");

}

