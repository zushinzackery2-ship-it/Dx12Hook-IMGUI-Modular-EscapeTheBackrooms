#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// 0x0024 (0x0024 - 0x0000)
struct DragonIK_Library_CustomLookRotation final
{
public:
	struct FVector                                lookAt;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                upDirection;                                       // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_CustomLookRotation) == 0x000004, "Wrong alignment on DragonIK_Library_CustomLookRotation");
static_assert(sizeof(DragonIK_Library_CustomLookRotation) == 0x000024, "Wrong size on DragonIK_Library_CustomLookRotation");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, lookAt) == 0x000000, "Member 'DragonIK_Library_CustomLookRotation::lookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, upDirection) == 0x00000C, "Member 'DragonIK_Library_CustomLookRotation::upDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_CustomLookRotation, ReturnValue) == 0x000018, "Member 'DragonIK_Library_CustomLookRotation::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// 0x0030 (0x0030 - 0x0000)
struct DragonIK_Library_LookAtRotation_V3 final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpVector;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtRotation_V3) == 0x000004, "Wrong alignment on DragonIK_Library_LookAtRotation_V3");
static_assert(sizeof(DragonIK_Library_LookAtRotation_V3) == 0x000030, "Wrong size on DragonIK_Library_LookAtRotation_V3");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Source) == 0x000000, "Member 'DragonIK_Library_LookAtRotation_V3::Source' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, Target) == 0x00000C, "Member 'DragonIK_Library_LookAtRotation_V3::Target' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, UpVector) == 0x000018, "Member 'DragonIK_Library_LookAtRotation_V3::UpVector' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtRotation_V3, ReturnValue) == 0x000024, "Member 'DragonIK_Library_LookAtRotation_V3::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// 0x0030 (0x0030 - 0x0000)
struct DragonIK_Library_LookAtVector_V2 final
{
public:
	struct FVector                                Source_Location;                                   // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                lookAt;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                upDirection;                                       // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_LookAtVector_V2) == 0x000004, "Wrong alignment on DragonIK_Library_LookAtVector_V2");
static_assert(sizeof(DragonIK_Library_LookAtVector_V2) == 0x000030, "Wrong size on DragonIK_Library_LookAtVector_V2");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, Source_Location) == 0x000000, "Member 'DragonIK_Library_LookAtVector_V2::Source_Location' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, lookAt) == 0x00000C, "Member 'DragonIK_Library_LookAtVector_V2::lookAt' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, upDirection) == 0x000018, "Member 'DragonIK_Library_LookAtVector_V2::upDirection' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_LookAtVector_V2, ReturnValue) == 0x000024, "Member 'DragonIK_Library_LookAtVector_V2::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// 0x0070 (0x0070 - 0x0000)
struct DragonIK_Library_QuatLookXatLocation final
{
public:
	struct FTransform                             LookAtFromTransform;                               // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtTarget;                                      // 0x0030(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0040(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIK_Library_QuatLookXatLocation) == 0x000010, "Wrong alignment on DragonIK_Library_QuatLookXatLocation");
static_assert(sizeof(DragonIK_Library_QuatLookXatLocation) == 0x000070, "Wrong size on DragonIK_Library_QuatLookXatLocation");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtFromTransform) == 0x000000, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtFromTransform' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, LookAtTarget) == 0x000030, "Member 'DragonIK_Library_QuatLookXatLocation::LookAtTarget' has a wrong offset!");
static_assert(offsetof(DragonIK_Library_QuatLookXatLocation, ReturnValue) == 0x000040, "Member 'DragonIK_Library_QuatLookXatLocation::ReturnValue' has a wrong offset!");

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// 0x00D0 (0x00D0 - 0x0000)
struct DragonIKFootStepsComponent_CallFootSteps final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             foot_transform;                                    // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         height_difference;                                 // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             hit_info;                                          // 0x0044(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKFootStepsComponent_CallFootSteps) == 0x000010, "Wrong alignment on DragonIKFootStepsComponent_CallFootSteps");
static_assert(sizeof(DragonIKFootStepsComponent_CallFootSteps) == 0x0000D0, "Wrong size on DragonIKFootStepsComponent_CallFootSteps");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, bone_name) == 0x000000, "Member 'DragonIKFootStepsComponent_CallFootSteps::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, foot_transform) == 0x000010, "Member 'DragonIKFootStepsComponent_CallFootSteps::foot_transform' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, height_difference) == 0x000040, "Member 'DragonIKFootStepsComponent_CallFootSteps::height_difference' has a wrong offset!");
static_assert(offsetof(DragonIKFootStepsComponent_CallFootSteps, hit_info) == 0x000044, "Member 'DragonIKFootStepsComponent_CallFootSteps::hit_info' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// 0x0050 (0x0050 - 0x0000)
struct DragonIKPhysicsComponent_Control_Bone_Handle final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             override_transform;                                // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000010, "Wrong alignment on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(sizeof(DragonIKPhysicsComponent_Control_Bone_Handle) == 0x000050, "Wrong size on DragonIKPhysicsComponent_Control_Bone_Handle");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, bone_name) == 0x000000, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::bone_name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, override_transform) == 0x000010, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::override_transform' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_Control_Bone_Handle, Enable) == 0x000040, "Member 'DragonIKPhysicsComponent_Control_Bone_Handle::Enable' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// 0x0008 (0x0008 - 0x0000)
struct DragonIKPhysicsComponent_FirstTimeInitialization final
{
public:
	class USkeletalMeshComponent*                 skeleton_input;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(sizeof(DragonIKPhysicsComponent_FirstTimeInitialization) == 0x000008, "Wrong size on DragonIKPhysicsComponent_FirstTimeInitialization");
static_assert(offsetof(DragonIKPhysicsComponent_FirstTimeInitialization, skeleton_input) == 0x000000, "Member 'DragonIKPhysicsComponent_FirstTimeInitialization::skeleton_input' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_Modify_Reset_Bone_Info final
{
public:
	TArray<class FName>                           bone_list;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000008, "Wrong alignment on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(sizeof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info) == 0x000010, "Wrong size on DragonIKPhysicsComponent_Modify_Reset_Bone_Info");
static_assert(offsetof(DragonIKPhysicsComponent_Modify_Reset_Bone_Info, bone_list) == 0x000000, "Member 'DragonIKPhysicsComponent_Modify_Reset_Bone_Info::bone_list' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// 0x00B0 (0x00B0 - 0x0000)
struct DragonIKPhysicsComponent_OnHitCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Optional_Override_Hit_Bone_Name;                   // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_location;                                      // 0x0090(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                hit_impulse_direction;                             // 0x009C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   hit_bone_name;                                     // 0x00A8(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_OnHitCallback) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_OnHitCallback");
static_assert(sizeof(DragonIKPhysicsComponent_OnHitCallback) == 0x0000B0, "Wrong size on DragonIKPhysicsComponent_OnHitCallback");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Hit) == 0x000000, "Member 'DragonIKPhysicsComponent_OnHitCallback::Hit' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, Optional_Override_Hit_Bone_Name) == 0x000088, "Member 'DragonIKPhysicsComponent_OnHitCallback::Optional_Override_Hit_Bone_Name' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_location) == 0x000090, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_location' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_impulse_direction) == 0x00009C, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_impulse_direction' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_OnHitCallback, hit_bone_name) == 0x0000A8, "Member 'DragonIKPhysicsComponent_OnHitCallback::hit_bone_name' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReGrabAllHandles final
{
public:
	bool                                          exit_ragdoll;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReGrabAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReGrabAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReGrabAllHandles, exit_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReGrabAllHandles::exit_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// 0x0001 (0x0001 - 0x0000)
struct DragonIKPhysicsComponent_ReleaseAllHandles final
{
public:
	bool                                          go_ragdoll;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong alignment on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(sizeof(DragonIKPhysicsComponent_ReleaseAllHandles) == 0x000001, "Wrong size on DragonIKPhysicsComponent_ReleaseAllHandles");
static_assert(offsetof(DragonIKPhysicsComponent_ReleaseAllHandles, go_ragdoll) == 0x000000, "Member 'DragonIKPhysicsComponent_ReleaseAllHandles::go_ragdoll' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// 0x0004 (0x0004 - 0x0000)
struct DragonIKPhysicsComponent_SetInterpolation final
{
public:
	int32                                         inter_value;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_SetInterpolation");
static_assert(sizeof(DragonIKPhysicsComponent_SetInterpolation) == 0x000004, "Wrong size on DragonIKPhysicsComponent_SetInterpolation");
static_assert(offsetof(DragonIKPhysicsComponent_SetInterpolation, inter_value) == 0x000000, "Member 'DragonIKPhysicsComponent_SetInterpolation::inter_value' has a wrong offset!");

// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// 0x0010 (0x0010 - 0x0000)
struct DragonIKPhysicsComponent_UpdatePhysanimData final
{
public:
	int32                                         LinearStrength;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularStrength;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearDamp;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularDamp;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000004, "Wrong alignment on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(sizeof(DragonIKPhysicsComponent_UpdatePhysanimData) == 0x000010, "Wrong size on DragonIKPhysicsComponent_UpdatePhysanimData");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearStrength) == 0x000000, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularStrength) == 0x000004, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularStrength' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, LinearDamp) == 0x000008, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::LinearDamp' has a wrong offset!");
static_assert(offsetof(DragonIKPhysicsComponent_UpdatePhysanimData, AngularDamp) == 0x00000C, "Member 'DragonIKPhysicsComponent_UpdatePhysanimData::AngularDamp' has a wrong offset!");

}

