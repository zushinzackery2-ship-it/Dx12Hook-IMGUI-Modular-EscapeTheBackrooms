#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SimpleScatterPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum SimpleScatterPlugin.EPropertyUpdateGroup
// NumValues: 0x0005
enum class EPropertyUpdateGroup : uint8
{
	InstancersPropertiesUpdate               = 0,
	ScatterUpdate                            = 1,
	TracedPointsUpdate                       = 2,
	EverythingUpdate                         = 3,
	EPropertyUpdateGroup_MAX                 = 4,
};

// Enum SimpleScatterPlugin.ESurfaceAlignMode
// NumValues: 0x0003
enum class ESurfaceAlignMode : uint8
{
	WorldAlign                               = 0,
	NormalAlign                              = 1,
	ESurfaceAlignMode_MAX                    = 2,
};

// Enum SimpleScatterPlugin.EScaleMode
// NumValues: 0x0004
enum class EScaleMode : uint8
{
	X                                        = 0,
	XZ                                       = 1,
	XYZ                                      = 2,
	EScaleMode_MAX                           = 3,
};

// Enum SimpleScatterPlugin.EDistributionMode
// NumValues: 0x0003
enum class EDistributionMode : uint8
{
	Random                                   = 0,
	Grid                                     = 1,
	EDistributionMode_MAX                    = 2,
};

// ScriptStruct SimpleScatterPlugin.Bounds
// 0x0018 (0x0018 - 0x0000)
struct FBounds final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBounds) == 0x000004, "Wrong alignment on FBounds");
static_assert(sizeof(FBounds) == 0x000018, "Wrong size on FBounds");
static_assert(offsetof(FBounds, Origin) == 0x000000, "Member 'FBounds::Origin' has a wrong offset!");
static_assert(offsetof(FBounds, Extents) == 0x00000C, "Member 'FBounds::Extents' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.TracedPoint
// 0x001C (0x001C - 0x0000)
struct FTracedPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextureColor;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTracedPoint) == 0x000004, "Wrong alignment on FTracedPoint");
static_assert(sizeof(FTracedPoint) == 0x00001C, "Wrong size on FTracedPoint");
static_assert(offsetof(FTracedPoint, Location) == 0x000000, "Member 'FTracedPoint::Location' has a wrong offset!");
static_assert(offsetof(FTracedPoint, Normal) == 0x00000C, "Member 'FTracedPoint::Normal' has a wrong offset!");
static_assert(offsetof(FTracedPoint, TextureColor) == 0x000018, "Member 'FTracedPoint::TextureColor' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.GeneratedPoint
// 0x0010 (0x0010 - 0x0000)
struct FGeneratedPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedPoint) == 0x000004, "Wrong alignment on FGeneratedPoint");
static_assert(sizeof(FGeneratedPoint) == 0x000010, "Wrong size on FGeneratedPoint");
static_assert(offsetof(FGeneratedPoint, Location) == 0x000000, "Member 'FGeneratedPoint::Location' has a wrong offset!");
static_assert(offsetof(FGeneratedPoint, Depth) == 0x00000C, "Member 'FGeneratedPoint::Depth' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.HeightDistributionLimit
// 0x0010 (0x0010 - 0x0000)
struct FHeightDistributionLimit final
{
public:
	bool                                          bUseHeightLimit;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightLimitMin;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightLimitMax;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeightLimitInvert;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeightDistributionLimit) == 0x000004, "Wrong alignment on FHeightDistributionLimit");
static_assert(sizeof(FHeightDistributionLimit) == 0x000010, "Wrong size on FHeightDistributionLimit");
static_assert(offsetof(FHeightDistributionLimit, bUseHeightLimit) == 0x000000, "Member 'FHeightDistributionLimit::bUseHeightLimit' has a wrong offset!");
static_assert(offsetof(FHeightDistributionLimit, HeightLimitMin) == 0x000004, "Member 'FHeightDistributionLimit::HeightLimitMin' has a wrong offset!");
static_assert(offsetof(FHeightDistributionLimit, HeightLimitMax) == 0x000008, "Member 'FHeightDistributionLimit::HeightLimitMax' has a wrong offset!");
static_assert(offsetof(FHeightDistributionLimit, bHeightLimitInvert) == 0x00000C, "Member 'FHeightDistributionLimit::bHeightLimitInvert' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.SlopeDistributionLimit
// 0x0010 (0x0010 - 0x0000)
struct FSlopeDistributionLimit final
{
public:
	bool                                          bUseSlopeLimit;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeLimitOffset;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeLimitContrast;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeLimitInvert;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlopeDistributionLimit) == 0x000004, "Wrong alignment on FSlopeDistributionLimit");
static_assert(sizeof(FSlopeDistributionLimit) == 0x000010, "Wrong size on FSlopeDistributionLimit");
static_assert(offsetof(FSlopeDistributionLimit, bUseSlopeLimit) == 0x000000, "Member 'FSlopeDistributionLimit::bUseSlopeLimit' has a wrong offset!");
static_assert(offsetof(FSlopeDistributionLimit, SlopeLimitOffset) == 0x000004, "Member 'FSlopeDistributionLimit::SlopeLimitOffset' has a wrong offset!");
static_assert(offsetof(FSlopeDistributionLimit, SlopeLimitContrast) == 0x000008, "Member 'FSlopeDistributionLimit::SlopeLimitContrast' has a wrong offset!");
static_assert(offsetof(FSlopeDistributionLimit, bSlopeLimitInvert) == 0x00000C, "Member 'FSlopeDistributionLimit::bSlopeLimitInvert' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.SlopeScaleFalloff
// 0x0010 (0x0010 - 0x0000)
struct FSlopeScaleFalloff final
{
public:
	float                                         SlopeFalloffEffect;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeFalloffOffset;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeFalloffContrast;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlopeFalloffInvert;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlopeScaleFalloff) == 0x000004, "Wrong alignment on FSlopeScaleFalloff");
static_assert(sizeof(FSlopeScaleFalloff) == 0x000010, "Wrong size on FSlopeScaleFalloff");
static_assert(offsetof(FSlopeScaleFalloff, SlopeFalloffEffect) == 0x000000, "Member 'FSlopeScaleFalloff::SlopeFalloffEffect' has a wrong offset!");
static_assert(offsetof(FSlopeScaleFalloff, SlopeFalloffOffset) == 0x000004, "Member 'FSlopeScaleFalloff::SlopeFalloffOffset' has a wrong offset!");
static_assert(offsetof(FSlopeScaleFalloff, SlopeFalloffContrast) == 0x000008, "Member 'FSlopeScaleFalloff::SlopeFalloffContrast' has a wrong offset!");
static_assert(offsetof(FSlopeScaleFalloff, SlopeFalloffInvert) == 0x00000C, "Member 'FSlopeScaleFalloff::SlopeFalloffInvert' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.ScatterSurface
// 0x0030 (0x0030 - 0x0000)
struct FScatterSurface final
{
public:
	class AActor*                                 Surface;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              DistributionMaterial;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeUV_Size;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         DistributionTexture;                               // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DistributionTextureSize;                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScatterSurface) == 0x000008, "Wrong alignment on FScatterSurface");
static_assert(sizeof(FScatterSurface) == 0x000030, "Wrong size on FScatterSurface");
static_assert(offsetof(FScatterSurface, Surface) == 0x000000, "Member 'FScatterSurface::Surface' has a wrong offset!");
static_assert(offsetof(FScatterSurface, DistributionMaterial) == 0x000008, "Member 'FScatterSurface::DistributionMaterial' has a wrong offset!");
static_assert(offsetof(FScatterSurface, LandscapeUV_Size) == 0x000010, "Member 'FScatterSurface::LandscapeUV_Size' has a wrong offset!");
static_assert(offsetof(FScatterSurface, DistributionTexture) == 0x000018, "Member 'FScatterSurface::DistributionTexture' has a wrong offset!");
static_assert(offsetof(FScatterSurface, DistributionTextureSize) == 0x000028, "Member 'FScatterSurface::DistributionTextureSize' has a wrong offset!");

// ScriptStruct SimpleScatterPlugin.InstancedMesh
// 0x0020 (0x0020 - 0x0000)
struct FInstancedMesh final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            Mobility;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHierarchicalInstancedStaticMeshComponent* Instancer;                                      // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstancedMesh) == 0x000008, "Wrong alignment on FInstancedMesh");
static_assert(sizeof(FInstancedMesh) == 0x000020, "Wrong size on FInstancedMesh");
static_assert(offsetof(FInstancedMesh, StaticMesh) == 0x000000, "Member 'FInstancedMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(FInstancedMesh, ScaleMultiplier) == 0x000008, "Member 'FInstancedMesh::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FInstancedMesh, Probability) == 0x00000C, "Member 'FInstancedMesh::Probability' has a wrong offset!");
static_assert(offsetof(FInstancedMesh, Mobility) == 0x000010, "Member 'FInstancedMesh::Mobility' has a wrong offset!");
static_assert(offsetof(FInstancedMesh, bEnableCollision) == 0x000011, "Member 'FInstancedMesh::bEnableCollision' has a wrong offset!");
static_assert(offsetof(FInstancedMesh, Instancer) == 0x000018, "Member 'FInstancedMesh::Instancer' has a wrong offset!");

}

