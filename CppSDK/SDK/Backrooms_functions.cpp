#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Backrooms

#include "Basic.hpp"

#include "Backrooms_classes.hpp"
#include "Backrooms_parameters.hpp"


namespace SDK
{

// Function Backrooms.InteractableActor.BlockUsage
// (Final, Native, Public, BlueprintCallable)

void AInteractableActor::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnBeginHighlight
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AInteractableActor::OnBeginHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnBeginHighlight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.InteractableActor.OnEndHighlight
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AInteractableActor::OnEndHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnEndHighlight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.InteractableActor.OnInteractStartedLocal
// (Event, Public, BlueprintEvent)

void AInteractableActor::OnInteractStartedLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnInteractStartedLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.InteractableActor.OnRep_IsUsable
// (Final, Native, Protected)

void AInteractableActor::OnRep_IsUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnRep_IsUsable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnRep_WasUsed
// (Final, Native, Public)

void AInteractableActor::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void AInteractableActor::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AInteractableActor::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void AInteractableActor::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)

void AInteractableActor::OnUsedServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.ResetUsage
// (Final, Native, Public, BlueprintCallable)

void AInteractableActor::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.PushableActor.GetClosesPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APushableActor::GetClosesPoint(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetClosesPoint");

	Params::PushableActor_GetClosesPoint Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.PushableActor.GetForwardBoundingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> APushableActor::GetForwardBoundingPoints(bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetForwardBoundingPoints");

	Params::PushableActor_GetForwardBoundingPoints Parms{};

	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.PushableActor.GetRightBoundingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> APushableActor::GetRightBoundingPoints(bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetRightBoundingPoints");

	Params::PushableActor_GetRightBoundingPoints Parms{};

	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.AI_ObjectWC.FinishExecute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::FinishExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "FinishExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AI_ObjectWC.GetWeight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAI_ObjectWC::GetWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "GetWeight");

	Params::AI_ObjectWC_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.AI_ObjectWC.OnUpdate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::OnUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "OnUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AI_ObjectWC.StartExecute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::StartExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "StartExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddEntitySighting
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddEntitySighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddEntitySighting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddLowSanityAmount
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddLowSanityAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddLowSanityAmount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddPlayerDeath
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddPlayerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddPlayerDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.SetTimeCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionData::SetTimeCompleted(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "SetTimeCompleted");

	Params::MissionData_SetTimeCompleted Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AimAssistComponent.CheckCanMove
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAimAssistComponent::CheckCanMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "CheckCanMove");

	Params::AimAssistComponent_CheckCanMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.AimAssistComponent.OnAimAssistDeviceEnabled
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::OnAimAssistDeviceEnabled(bool IsGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "OnAimAssistDeviceEnabled");

	Params::AimAssistComponent_OnAimAssistDeviceEnabled Parms{};

	Parms.IsGamepad = IsGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AimAssistComponent.ProcessAimAssist
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const float                             DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator UAimAssistComponent::ProcessAimAssist(const float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ProcessAimAssist");

	Params::AimAssistComponent_ProcessAimAssist Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.AimAssistComponent.GetCurrentTargetOrDefault
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAimAssistTarget                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAimAssistTarget UAimAssistComponent::GetCurrentTargetOrDefault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "GetCurrentTargetOrDefault");

	Params::AimAssistComponent_GetCurrentTargetOrDefault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.AddXP
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   xpToAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBackroomsBPFunctionLibrary::AddXP(float xpToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "AddXP");

	Params::BackroomsBPFunctionLibrary_AddXP Parms{};

	Parms.xpToAdd = xpToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.CanNavigationReachPoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBackroomsBPFunctionLibrary::CanNavigationReachPoint(class APawn* Pawn, const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "CanNavigationReachPoint");

	Params::BackroomsBPFunctionLibrary_CanNavigationReachPoint Parms{};

	Parms.Pawn = Pawn;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ClearCharacterFloor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::ClearCharacterFloor(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ClearCharacterFloor");

	Params::BackroomsBPFunctionLibrary_ClearCharacterFloor Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ClearVoice
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ClearVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ClearVoice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.DeleteInputSettings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::DeleteInputSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "DeleteInputSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.DetectCurrentGesture
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const TArray<float>&                    PoseFingerCurls                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UOpenInputGestureDatabase*        GesturesDB                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBackroomsBPFunctionLibrary::DetectCurrentGesture(const TArray<float>& PoseFingerCurls, class UOpenInputGestureDatabase* GesturesDB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "DetectCurrentGesture");

	Params::BackroomsBPFunctionLibrary_DetectCurrentGesture Parms{};

	Parms.PoseFingerCurls = std::move(PoseFingerCurls);
	Parms.GesturesDB = GesturesDB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetAllSaveGameSlotNames
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBackroomsBPFunctionLibrary::GetAllSaveGameSlotNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetAllSaveGameSlotNames");

	Params::BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetDateFromSeconds
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UBackroomsBPFunctionLibrary::GetDateFromSeconds(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetDateFromSeconds");

	Params::BackroomsBPFunctionLibrary_GetDateFromSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetIndexOfClosestSplinePoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBackroomsBPFunctionLibrary::GetIndexOfClosestSplinePoint(class USplineComponent* SplineComponent, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetIndexOfClosestSplinePoint");

	Params::BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint Parms{};

	Parms.SplineComponent = SplineComponent;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetPlayerStateArray
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGameStateBase*                   GameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerState*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerState*> UBackroomsBPFunctionLibrary::GetPlayerStateArray(class AGameStateBase* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetPlayerStateArray");

	Params::BackroomsBPFunctionLibrary_GetPlayerStateArray Parms{};

	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSaveGameSlotsByType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBackroomsBPFunctionLibrary::GetSaveGameSlotsByType(const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSaveGameSlotsByType");

	Params::BackroomsBPFunctionLibrary_GetSaveGameSlotsByType Parms{};

	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSplinePoints
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UBackroomsBPFunctionLibrary::GetSplinePoints(class USplineComponent* SplineComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSplinePoints");

	Params::BackroomsBPFunctionLibrary_GetSplinePoints Parms{};

	Parms.SplineComponent = SplineComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSystemTimeSeconds
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDateTime&                 DateTime                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBackroomsBPFunctionLibrary::GetSystemTimeSeconds(const struct FDateTime& DateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSystemTimeSeconds");

	Params::BackroomsBPFunctionLibrary_GetSystemTimeSeconds Parms{};

	Parms.DateTime = std::move(DateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetViewDistanceScale
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBackroomsBPFunctionLibrary::GetViewDistanceScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetViewDistanceScale");

	Params::BackroomsBPFunctionLibrary_GetViewDistanceScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.IsNoHMDMode
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBackroomsBPFunctionLibrary::IsNoHMDMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "IsNoHMDMode");

	Params::BackroomsBPFunctionLibrary_IsNoHMDMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.K2_IsTearingDown
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   isTearingDown                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::K2_IsTearingDown(class UObject* caller, bool* isTearingDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "K2_IsTearingDown");

	Params::BackroomsBPFunctionLibrary_K2_IsTearingDown Parms{};

	Parms.caller = caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (isTearingDown != nullptr)
		*isTearingDown = Parms.isTearingDown;
}


// Function Backrooms.BackroomsBPFunctionLibrary.LoadXP
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBackroomsBPFunctionLibrary::LoadXP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "LoadXP");

	Params::BackroomsBPFunctionLibrary_LoadXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.PatchMissingInputActions
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const TArray<struct FInputActionKeyMapping>&NewActions                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::PatchMissingInputActions(const TArray<struct FInputActionKeyMapping>& NewActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "PatchMissingInputActions");

	Params::BackroomsBPFunctionLibrary_PatchMissingInputActions Parms{};

	Parms.NewActions = std::move(NewActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.PlayRate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UTimelineComponent*               Timeline                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Sec                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimelineComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimelineComponent* UBackroomsBPFunctionLibrary::PlayRate(class UTimelineComponent* Timeline, float Sec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "PlayRate");

	Params::BackroomsBPFunctionLibrary_PlayRate Parms{};

	Parms.Timeline = Timeline;
	Parms.Sec = Sec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ReloadBindings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ReloadBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ReloadBindings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ResetInputSettings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ResetInputSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ResetInputSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ResetWorldTime
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class AGameMode*                  GameMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::ResetWorldTime(const class AGameMode* GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ResetWorldTime");

	Params::BackroomsBPFunctionLibrary_ResetWorldTime Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SaveToClipboard
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    ToClipboard                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SaveToClipboard(const class FString& ToClipboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SaveToClipboard");

	Params::BackroomsBPFunctionLibrary_SaveToClipboard Parms{};

	Parms.ToClipboard = std::move(ToClipboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SetCurrentLevelLogs
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SetCurrentLevelLogs(const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SetCurrentLevelLogs");

	Params::BackroomsBPFunctionLibrary_SetCurrentLevelLogs Parms{};

	Parms.LevelName = std::move(LevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SetLogValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SetLogValue(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SetLogValue");

	Params::BackroomsBPFunctionLibrary_SetLogValue Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.DisableAllEngines
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::DisableAllEngines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "DisableAllEngines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.DisableAllFloaters
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::DisableAllFloaters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "DisableAllFloaters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.EnableAllEngines
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::EnableAllEngines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "EnableAllEngines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.EnableAllFloaters
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::EnableAllFloaters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "EnableAllFloaters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.GetShipBoundsRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBoatComponent::GetShipBoundsRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "GetShipBoundsRadius");

	Params::BoatComponent_GetShipBoundsRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.GetXShipPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ABoatPawn*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABoatPawn* UBoatComponent::GetXShipPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "GetXShipPawn");

	Params::BoatComponent_GetXShipPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.IsEngineInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBoatComponent::IsEngineInWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "IsEngineInWater");

	Params::BoatComponent_IsEngineInWater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.Server_PassMovementInfo
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// const struct FRepXShipMovement&         NewRepXShipMovement                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBoatComponent::Server_PassMovementInfo(const struct FRepXShipMovement& NewRepXShipMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "Server_PassMovementInfo");

	Params::BoatComponent_Server_PassMovementInfo Parms{};

	Parms.NewRepXShipMovement = std::move(NewRepXShipMovement);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.ChangeCrosshairVisibility
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::ChangeCrosshairVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "ChangeCrosshairVisibility");

	Params::FancyCharacter_ChangeCrosshairVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.CheckPawn
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyCharacter::CheckPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "CheckPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.CheckSpawnedItems
// (Native, Event, Public, BlueprintEvent)

void AFancyCharacter::CheckSpawnedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "CheckSpawnedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.HideItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::HideItem(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "HideItem");

	Params::FancyCharacter_HideItem Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.Interact
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::Interact(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "Interact");

	Params::FancyCharacter_Interact Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.InteractCallBackVR
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::InteractCallBackVR(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "InteractCallBackVR");

	Params::FancyCharacter_InteractCallBackVR Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.KillPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bResetInteractable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::KillPlayer(bool bResetInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "KillPlayer");

	Params::FancyCharacter_KillPlayer Parms{};

	Parms.bResetInteractable = bResetInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnRep_CanCollide
// (Final, Native, Private)

void AFancyCharacter::OnRep_CanCollide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnRep_CanCollide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnRep_IsOverlapOnly
// (Final, Native, Private)

void AFancyCharacter::OnRep_IsOverlapOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnRep_IsOverlapOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnSanityUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Sanity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::OnSanityUpdate(float Sanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnSanityUpdate");

	Params::FancyCharacter_OnSanityUpdate Parms{};

	Parms.Sanity = Sanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.SetCanCollide
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    ShouldCollide                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::SetCanCollide(bool ShouldCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "SetCanCollide");

	Params::FancyCharacter_SetCanCollide Parms{};

	Parms.ShouldCollide = ShouldCollide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.SetIsOverlapOnly
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    ShouldOverlapOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::SetIsOverlapOnly(bool ShouldOverlapOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "SetIsOverlapOnly");

	Params::FancyCharacter_SetIsOverlapOnly Parms{};

	Parms.ShouldOverlapOnly = ShouldOverlapOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.StopPushing
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AFancyCharacter::StopPushing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "StopPushing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.ToggleBlur
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ShouldBlur                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::ToggleBlur(bool ShouldBlur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "ToggleBlur");

	Params::FancyCharacter_ToggleBlur Parms{};

	Parms.ShouldBlur = ShouldBlur;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TogglePlayerLegs
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::TogglePlayerLegs(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TogglePlayerLegs");

	Params::FancyCharacter_TogglePlayerLegs Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TogglePlayerVisibility
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::TogglePlayerVisibility(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TogglePlayerVisibility");

	Params::FancyCharacter_TogglePlayerVisibility Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TryPickup
// (Native, Event, Public, BlueprintEvent)

void AFancyCharacter::TryPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TryPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.GetCurrentInteractableActor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AFancyCharacter::GetCurrentInteractableActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "GetCurrentInteractableActor");

	Params::FancyCharacter_GetCurrentInteractableActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InteractablePawn.BlockUsage
// (Native, Public, BlueprintCallable)

void AInteractablePawn::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnAttemptUse
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    CanUse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnAttemptUse(bool CanUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnAttemptUse");

	Params::InteractablePawn_OnAttemptUse Parms{};

	Parms.CanUse = CanUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnHiddenPossess
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnHiddenPossess(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnHiddenPossess");

	Params::InteractablePawn_OnHiddenPossess Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnPossess
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnPossess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnPossess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnRep_IsUsable
// (Final, Native, Protected)

void AInteractablePawn::OnRep_IsUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnRep_IsUsable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnRep_WasUsed
// (Final, Native, Public)

void AInteractablePawn::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnStartInteracting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnStartInteracting(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnStartInteracting");

	Params::InteractablePawn_OnStartInteracting Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnStopInteracting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AInteractablePawn::OnStopInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnStopInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUnPossess
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUnPossess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUnPossess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AInteractablePawn::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnUsedServer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedServer");

	Params::InteractablePawn_OnUsedServer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnVRPossess
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPossess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnVRPossess(bool bPossess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnVRPossess");

	Params::InteractablePawn_OnVRPossess Parms{};

	Parms.bPossess = bPossess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.ResetUsage
// (Native, Public, BlueprintCallable)

void AInteractablePawn::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.SetCameraPostProcessing
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::SetCameraPostProcessing(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "SetCameraPostProcessing");

	Params::InteractablePawn_SetCameraPostProcessing Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.SetUsingVR
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPossess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::SetUsingVR(class ACharacter* Character, bool bPossess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "SetUsingVR");

	Params::InteractablePawn_SetUsingVR Parms{};

	Parms.Character = Character;
	Parms.bPossess = bPossess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.ToggleMouse
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    bHide                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::ToggleMouse(bool bHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "ToggleMouse");

	Params::InteractablePawn_ToggleMouse Parms{};

	Parms.bHide = bHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatPawn.AddRotationInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ScaleValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABoatPawn::AddRotationInput(float ScaleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "AddRotationInput");

	Params::BoatPawn_AddRotationInput Parms{};

	Parms.ScaleValue = ScaleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatPawn.GetWaterDensity
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABoatPawn::GetWaterDensity(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterDensity");

	Params::BoatPawn_GetWaterDensity Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetWaterNormal
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ABoatPawn::GetWaterNormal(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterNormal");

	Params::BoatPawn_GetWaterNormal Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetWaterWorldZ
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABoatPawn::GetWaterWorldZ(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterWorldZ");

	Params::BoatPawn_GetWaterWorldZ Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetXShipComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBoatComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoatComponent* ABoatPawn::GetXShipComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetXShipComponent");

	Params::BoatPawn_GetXShipComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.ClientInteractableActor.OnUsed
// (Native, Event, Public, BlueprintEvent)

void AClientInteractableActor::OnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInteractableActor", "OnUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ClientInteractablePawn.OnUsed
// (Native, Event, Public, BlueprintEvent)

void AClientInteractablePawn::OnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInteractablePawn", "OnUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarrier.ForceDropCarry
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)

void UFancyCarrySystemCarrier::ForceDropCarry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "ForceDropCarry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarrier.OnRep_CurrentCarryable
// (Final, Native, Protected)
// Parameters:
// class UFancyCarrySystemCarryable*       PreviousCarryable                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyCarrySystemCarrier::OnRep_CurrentCarryable(class UFancyCarrySystemCarryable* PreviousCarryable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "OnRep_CurrentCarryable");

	Params::FancyCarrySystemCarrier_OnRep_CurrentCarryable Parms{};

	Parms.PreviousCarryable = PreviousCarryable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarrier.StartCarry
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class UFancyCarrySystemCarryable*       Carryable                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyCarrySystemCarrier::StartCarry(class UFancyCarrySystemCarryable* Carryable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "StartCarry");

	Params::FancyCarrySystemCarrier_StartCarry Parms{};

	Parms.Carryable = Carryable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarrier.StopCarry
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void UFancyCarrySystemCarrier::StopCarry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "StopCarry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarrier.GetCurrentCarryable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFancyCarrySystemCarryable*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFancyCarrySystemCarryable* UFancyCarrySystemCarrier::GetCurrentCarryable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "GetCurrentCarryable");

	Params::FancyCarrySystemCarrier_GetCurrentCarryable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyCarrySystemCarrier.GetCurrentFocusedCarryable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFancyCarrySystemCarryable*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFancyCarrySystemCarryable* UFancyCarrySystemCarrier::GetCurrentFocusedCarryable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "GetCurrentFocusedCarryable");

	Params::FancyCarrySystemCarrier_GetCurrentFocusedCarryable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyCarrySystemCarrier.IsCarrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyCarrySystemCarrier::IsCarrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarrier", "IsCarrying");

	Params::FancyCarrySystemCarrier_IsCarrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MotionScannerDirector.CheckLIDARDots
// (Final, Native, Protected, BlueprintCallable)

void AMotionScannerDirector::CheckLIDARDots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerDirector", "CheckLIDARDots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.CustomUserWidget.RefreshInventory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomUserWidget::RefreshInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "RefreshInventory");

	Params::CustomUserWidget_RefreshInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Backrooms.CustomUserWidget.SetHotbarSlot
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomUserWidget::SetHotbarSlot(int32 ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "SetHotbarSlot");

	Params::CustomUserWidget_SetHotbarSlot Parms{};

	Parms.ItemSlot = ItemSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.CustomUserWidget.ToggleInventory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomUserWidget::ToggleInventory(bool IsVisible_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "ToggleInventory");

	Params::CustomUserWidget_ToggleInventory Parms{};

	Parms.IsVisible_0 = IsVisible_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.DroppedItem.EvaluatePhysics
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADroppedItem::EvaluatePhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "EvaluatePhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.OnBeginFocus
// (Native, Event, Public, BlueprintEvent)

void ADroppedItem::OnBeginFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "OnBeginFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.OnEndFocus
// (Native, Event, Public, BlueprintEvent)

void ADroppedItem::OnEndFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "OnEndFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.StopPhysics
// (Final, Native, Private)

void ADroppedItem::StopPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "StopPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.UpdatePhysicsLocation
// (Final, Native, Private)

void ADroppedItem::UpdatePhysicsLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "UpdatePhysicsLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarryable.OnRep_CurrentCarrier
// (Final, Native, Protected)

void UFancyCarrySystemCarryable::OnRep_CurrentCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarryable", "OnRep_CurrentCarrier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarryable.SetCanBeCarried
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    CanBeCarried                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyCarrySystemCarryable::SetCanBeCarried(bool CanBeCarried)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarryable", "SetCanBeCarried");

	Params::FancyCarrySystemCarryable_SetCanBeCarried Parms{};

	Parms.CanBeCarried = CanBeCarried;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCarrySystemCarryable.CanBeCarried
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyCarrySystemCarryable::CanBeCarried() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarryable", "CanBeCarried");

	Params::FancyCarrySystemCarryable_CanBeCarried Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyCarrySystemCarryable.IsBeingCarried
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyCarrySystemCarryable::IsBeingCarried() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCarrySystemCarryable", "IsBeingCarried");

	Params::FancyCarrySystemCarryable_IsBeingCarried Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyEntitySightingManager.OnEntitySighting
// (Final, Native, Public)
// Parameters:
// class UFancyEntitySightingComponent*    Entity                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyEntitySightingManager::OnEntitySighting(class UFancyEntitySightingComponent* Entity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyEntitySightingManager", "OnEntitySighting");

	Params::FancyEntitySightingManager_OnEntitySighting Parms{};

	Parms.Entity = Entity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyEntitySightingManager.GetNumEntitySightings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFancyEntitySightingManager::GetNumEntitySightings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyEntitySightingManager", "GetNumEntitySightings");

	Params::FancyEntitySightingManager_GetNumEntitySightings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyFileSystemUtilsLibrary.LoadCurrentGameAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UFancyFileSystemUtilsLibrary::LoadCurrentGameAsync(const class UObject* WorldContextObject, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyFileSystemUtilsLibrary", "LoadCurrentGameAsync");

	Params::FancyFileSystemUtilsLibrary_LoadCurrentGameAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyFileSystemUtilsLibrary.SaveGameToSlotAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGameObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bForceSave                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyFileSystemUtilsLibrary::SaveGameToSlotAsync(const class UObject* WorldContextObject, class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex, const bool bForceSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyFileSystemUtilsLibrary", "SaveGameToSlotAsync");

	Params::FancyFileSystemUtilsLibrary_SaveGameToSlotAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SaveGameObject = SaveGameObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.bForceSave = bForceSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyFileSystemUtilsLibrary.WriteStringToSaveFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyFileSystemUtilsLibrary::WriteStringToSaveFile(const class FString& Filename, const class FString& Content, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyFileSystemUtilsLibrary", "WriteStringToSaveFile");

	Params::FancyFileSystemUtilsLibrary_WriteStringToSaveFile Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Content = std::move(Content);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.CheckCurrentEvent
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::CheckCurrentEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CheckCurrentEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.CompleteMission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeCompleted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionStructure                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMissionStructure UFancyGameInstance::CompleteMission(float TimeCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CompleteMission");

	Params::FancyGameInstance_CompleteMission Parms{};

	Parms.TimeCompleted = TimeCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.CreateMission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    TargetEscapeLevel                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LevelBaseXP                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LevelTimeLimit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MissionStructRowName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::CreateMission(const class FString& TargetEscapeLevel, float LevelBaseXP, float LevelTimeLimit, const class FString& MissionStructRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CreateMission");

	Params::FancyGameInstance_CreateMission Parms{};

	Parms.TargetEscapeLevel = std::move(TargetEscapeLevel);
	Parms.LevelBaseXP = LevelBaseXP;
	Parms.LevelTimeLimit = LevelTimeLimit;
	Parms.MissionStructRowName = std::move(MissionStructRowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.GetCurrentGameLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFancyGameInstance::GetCurrentGameLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "GetCurrentGameLanguage");

	Params::FancyGameInstance_GetCurrentGameLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.InitializeCPPElements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyGameInstance::InitializeCPPElements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "InitializeCPPElements");

	Params::FancyGameInstance_InitializeCPPElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.InitializeStats
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::InitializeStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "InitializeStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.OnInputDeviceChange
// (Final, Native, Protected)
// Parameters:
// const EInputDevices                     NewInputDevice                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::OnInputDeviceChange(const EInputDevices NewInputDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "OnInputDeviceChange");

	Params::FancyGameInstance_OnInputDeviceChange Parms{};

	Parms.NewInputDevice = NewInputDevice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.OnInputDeviceChangedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EFancyInputDevice                 NewInputDevice                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::OnInputDeviceChangedEvent(const EFancyInputDevice NewInputDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "OnInputDeviceChangedEvent");

	Params::FancyGameInstance_OnInputDeviceChangedEvent Parms{};

	Parms.NewInputDevice = NewInputDevice;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.FancyGameInstance.OnSteamOverlayIsActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isOverlayActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::OnSteamOverlayIsActive(bool isOverlayActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "OnSteamOverlayIsActive");

	Params::FancyGameInstance_OnSteamOverlayIsActive Parms{};

	Parms.isOverlayActive = isOverlayActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.FancyGameInstance.ResetAchievements
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.UpdateCurrentGameLanguage
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::UpdateCurrentGameLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "UpdateCurrentGameLanguage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameMode.OnDecreaseSanity
// (Native, Event, Protected, BlueprintEvent)

void AFancyGameMode::OnDecreaseSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameMode", "OnDecreaseSanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameMode.OnPreLoadMap
// (Final, Native, Protected)
// Parameters:
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyGameMode::OnPreLoadMap(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameMode", "OnPreLoadMap");

	Params::FancyGameMode_OnPreLoadMap Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyInputIconWidget.OnInputDeviceChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EFancyInputDevice                       NewInputDevice                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyInputIconWidget::OnInputDeviceChanged(EFancyInputDevice NewInputDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyInputIconWidget", "OnInputDeviceChanged");

	Params::FancyInputIconWidget_OnInputDeviceChanged Parms{};

	Parms.NewInputDevice = NewInputDevice;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.FancyMovementComponent.SetSprinting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Sprint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyMovementComponent::SetSprinting(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyMovementComponent", "SetSprinting");

	Params::FancyMovementComponent_SetSprinting Parms{};

	Parms.Sprint = Sprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformActivities.EndActivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActivityCompletionStatus               Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformActivities::EndActivity(const class FString& ActivityName, EActivityCompletionStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "EndActivity");

	Params::FancyPlatformActivities_EndActivity Parms{};

	Parms.ActivityName = std::move(ActivityName);
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformActivities.GetLastPlayedActivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFancyPlatformActivities::GetLastPlayedActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "GetLastPlayedActivity");

	Params::FancyPlatformActivities_GetLastPlayedActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformActivities.IsActivityCallbackReceived
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformActivities::IsActivityCallbackReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "IsActivityCallbackReceived");

	Params::FancyPlatformActivities_IsActivityCallbackReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformActivities.ResumeActivity
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformActivities::ResumeActivity(const class FString& ActivityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "ResumeActivity");

	Params::FancyPlatformActivities_ResumeActivity Parms{};

	Parms.ActivityName = std::move(ActivityName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformActivities.SetActivityAvailability
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformActivities::SetActivityAvailability(const class FString& ActivityName, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "SetActivityAvailability");

	Params::FancyPlatformActivities_SetActivityAvailability Parms{};

	Parms.ActivityName = std::move(ActivityName);
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformActivities.SetLastPlayedActivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ActivityIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformActivities::SetLastPlayedActivity(int32 ActivityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "SetLastPlayedActivity");

	Params::FancyPlatformActivities_SetLastPlayedActivity Parms{};

	Parms.ActivityIndex = ActivityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformActivities.StartActivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActivityName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformActivities::StartActivity(const class FString& ActivityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformActivities", "StartActivity");

	Params::FancyPlatformActivities_StartActivity Parms{};

	Parms.ActivityName = std::move(ActivityName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformUtilsLibrary.GetCurrentInputDevice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFancyInputDevice                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFancyInputDevice UFancyPlatformUtilsLibrary::GetCurrentInputDevice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "GetCurrentInputDevice");

	Params::FancyPlatformUtilsLibrary_GetCurrentInputDevice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.GetGameVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFancyPlatformUtilsLibrary::GetGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "GetGameVersion");

	Params::FancyPlatformUtilsLibrary_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsCommunicationRestricted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsCommunicationRestricted(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsCommunicationRestricted");

	Params::FancyPlatformUtilsLibrary_IsCommunicationRestricted Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsConnectedToNetwork
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsConnectedToNetwork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsConnectedToNetwork");

	Params::FancyPlatformUtilsLibrary_IsConnectedToNetwork Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsConsoleBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsConsoleBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsConsoleBuild");

	Params::FancyPlatformUtilsLibrary_IsConsoleBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsEditor");

	Params::FancyPlatformUtilsLibrary_IsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnAnySonyPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnAnySonyPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnAnySonyPlatform");

	Params::FancyPlatformUtilsLibrary_IsOnAnySonyPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnAnyXboxPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnAnyXboxPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnAnyXboxPlatform");

	Params::FancyPlatformUtilsLibrary_IsOnAnyXboxPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnPS4Platform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnPS4Platform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnPS4Platform");

	Params::FancyPlatformUtilsLibrary_IsOnPS4Platform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnPS5Platform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnPS5Platform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnPS5Platform");

	Params::FancyPlatformUtilsLibrary_IsOnPS5Platform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnXboxOnePlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnXboxOnePlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnXboxOnePlatform");

	Params::FancyPlatformUtilsLibrary_IsOnXboxOnePlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnXboxSeriesPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnXboxSeriesPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnXboxSeriesPlatform");

	Params::FancyPlatformUtilsLibrary_IsOnXboxSeriesPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsOnXboxSeriesSPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsOnXboxSeriesSPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsOnXboxSeriesSPlatform");

	Params::FancyPlatformUtilsLibrary_IsOnXboxSeriesSPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "IsShippingBuild");

	Params::FancyPlatformUtilsLibrary_IsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlatformUtilsLibrary.SetUsingMultiplayerFeatures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsingMP                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyPlatformUtilsLibrary::SetUsingMultiplayerFeatures(const class APlayerController* PlayerController, bool bUsingMP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "SetUsingMultiplayerFeatures");

	Params::FancyPlatformUtilsLibrary_SetUsingMultiplayerFeatures Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bUsingMP = bUsingMP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlatformUtilsLibrary.SubscriptionCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyPlatformUtilsLibrary::SubscriptionCheck(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FancyPlatformUtilsLibrary", "SubscriptionCheck");

	Params::FancyPlatformUtilsLibrary_SubscriptionCheck Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlayerController.ClientHUDInit
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AFancyPlayerController::ClientHUDInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "ClientHUDInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.FancyPlayerController.GetObjectScreenRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMeshComponent*             MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFancyPlayerController::GetObjectScreenRadius(class UStaticMeshComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "GetObjectScreenRadius");

	Params::FancyPlayerController_GetObjectScreenRadius Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlayerController.OnPlayerTravel
// (Native, Event, Protected, BlueprintEvent)

void AFancyPlayerController::OnPlayerTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "OnPlayerTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerController.PrintLevelTimes
// (Event, Public, BlueprintEvent)

void AFancyPlayerController::PrintLevelTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "PrintLevelTimes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.FancyPlayerController.PrintLevelTimesToLog
// (Final, Exec, Native, Public)

void AFancyPlayerController::PrintLevelTimesToLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "PrintLevelTimesToLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.AddSanity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyPlayerState::AddSanity(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "AddSanity");

	Params::FancyPlayerState_AddSanity Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.OnKillPlayer
// (Native, Event, Public, BlueprintEvent)

void AFancyPlayerState::OnKillPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "OnKillPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.OnRep_Sanity
// (Final, Native, Public)

void AFancyPlayerState::OnRep_Sanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "OnRep_Sanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.RemoveSanity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyPlayerState::RemoveSanity(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "RemoveSanity");

	Params::FancyPlayerState_RemoveSanity Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyUserControllerSystem.EstablishInitialUser
// (Final, Native, Public, BlueprintCallable)

void UFancyUserControllerSystem::EstablishInitialUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "EstablishInitialUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyUserControllerSystem.GetActiveUserIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UFancyUserControllerSystem::GetActiveUserIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "GetActiveUserIcon");

	Params::FancyUserControllerSystem_GetActiveUserIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyUserControllerSystem.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFancyUserControllerSystem::GetDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "GetDisplayName");

	Params::FancyUserControllerSystem_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyUserControllerSystem.OpenAccountPickerFromBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyUserControllerSystem::OpenAccountPickerFromBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "OpenAccountPickerFromBP");

	Params::FancyUserControllerSystem_OpenAccountPickerFromBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyUserControllerSystem.SetUnpauseBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIsUnpauseBlocked                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyUserControllerSystem::SetUnpauseBlocked(bool bNewIsUnpauseBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "SetUnpauseBlocked");

	Params::FancyUserControllerSystem_SetUnpauseBlocked Parms{};

	Parms.bNewIsUnpauseBlocked = bNewIsUnpauseBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyUserControllerSystem.GetCurrentConnectionStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOnlineStatus                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOnlineStatus UFancyUserControllerSystem::GetCurrentConnectionStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "GetCurrentConnectionStatus");

	Params::FancyUserControllerSystem_GetCurrentConnectionStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyUserControllerSystem.HasEstablishedInitialUser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyUserControllerSystem::HasEstablishedInitialUser() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "HasEstablishedInitialUser");

	Params::FancyUserControllerSystem_HasEstablishedInitialUser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyUserControllerSystem.HasValidUser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyUserControllerSystem::HasValidUser() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyUserControllerSystem", "HasValidUser");

	Params::FancyUserControllerSystem_HasValidUser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVideoPlayer.OnMediaClosed
// (Final, Native, Protected)

void AFancyVideoPlayer::OnMediaClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnMediaClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.OnMediaReachedEnd
// (Final, Native, Protected)

void AFancyVideoPlayer::OnMediaReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnMediaReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.OnPlaybackSuspended
// (Final, Native, Protected)

void AFancyVideoPlayer::OnPlaybackSuspended()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnPlaybackSuspended");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.OnSkipVoteFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyVideoPlayer::OnSkipVoteFinished(bool Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnSkipVoteFinished");

	Params::FancyVideoPlayer_OnSkipVoteFinished Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.OnVideoEnded
// (Event, Protected, BlueprintEvent)

void AFancyVideoPlayer::OnVideoEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnVideoEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.FancyVideoPlayer.OnVideoStarted
// (Event, Protected, BlueprintEvent)

void AFancyVideoPlayer::OnVideoStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "OnVideoStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.FancyVideoPlayer.PauseVideoClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AFancyVideoPlayer::PauseVideoClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "PauseVideoClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.PauseVideoServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyVideoPlayer::PauseVideoServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "PauseVideoServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.PlayVideoClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class FString&                    MediaFileName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddToQueue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyVideoPlayer::PlayVideoClients(const class FString& MediaFileName, bool AddToQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "PlayVideoClients");

	Params::FancyVideoPlayer_PlayVideoClients Parms{};

	Parms.MediaFileName = std::move(MediaFileName);
	Parms.AddToQueue = AddToQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.PlayVideoServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class FString&                    MediaFileName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddToQueue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyVideoPlayer::PlayVideoServer(const class FString& MediaFileName, bool AddToQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "PlayVideoServer");

	Params::FancyVideoPlayer_PlayVideoServer Parms{};

	Parms.MediaFileName = std::move(MediaFileName);
	Parms.AddToQueue = AddToQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.SetCanSkip
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    CanSkip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyVideoPlayer::SetCanSkip(bool CanSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "SetCanSkip");

	Params::FancyVideoPlayer_SetCanSkip Parms{};

	Parms.CanSkip = CanSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.SkipVideoClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AFancyVideoPlayer::SkipVideoClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "SkipVideoClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.SkipVideoServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyVideoPlayer::SkipVideoServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "SkipVideoServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.StopVideoClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AFancyVideoPlayer::StopVideoClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "StopVideoClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.StopVideoServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyVideoPlayer::StopVideoServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "StopVideoServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoPlayer.CanSkip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFancyVideoPlayer::CanSkip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "CanSkip");

	Params::FancyVideoPlayer_CanSkip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVideoPlayer.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFancyVideoPlayer::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoPlayer", "IsPlaying");

	Params::FancyVideoPlayer_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVideoSubsystem.PauseVideo
// (Final, Native, Public, BlueprintCallable)

void UFancyVideoSubsystem::PauseVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "PauseVideo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoSubsystem.PlayVideo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    MediaFileName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddToQueue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyVideoSubsystem::PlayVideo(const class FString& MediaFileName, bool AddToQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "PlayVideo");

	Params::FancyVideoSubsystem_PlayVideo Parms{};

	Parms.MediaFileName = std::move(MediaFileName);
	Parms.AddToQueue = AddToQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoSubsystem.SkipVideo
// (Final, Native, Public, BlueprintCallable)

void UFancyVideoSubsystem::SkipVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "SkipVideo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoSubsystem.StopVideo
// (Final, Native, Public, BlueprintCallable)

void UFancyVideoSubsystem::StopVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "StopVideo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVideoSubsystem.GetActiveVideoPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFancyVideoPlayer*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFancyVideoPlayer* UFancyVideoSubsystem::GetActiveVideoPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "GetActiveVideoPlayer");

	Params::FancyVideoSubsystem_GetActiveVideoPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVideoSubsystem.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyVideoSubsystem::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVideoSubsystem", "IsPlaying");

	Params::FancyVideoSubsystem_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVotingComponent.ChangeVoteServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyVotingComponent::ChangeVoteServer(class APlayerState* PlayerState, bool NewVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "ChangeVoteServer");

	Params::FancyVotingComponent_ChangeVoteServer Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewVote = NewVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.CheckVoteFinishedCondition
// (Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyVotingComponent::CheckVoteFinishedCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "CheckVoteFinishedCondition");

	Params::FancyVotingComponent_CheckVoteFinishedCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyVotingComponent.FinishVoteMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyVotingComponent::FinishVoteMulticast(bool Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "FinishVoteMulticast");

	Params::FancyVotingComponent_FinishVoteMulticast Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.FinishVoteServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UFancyVotingComponent::FinishVoteServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "FinishVoteServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.StartVoteMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FVoteParameters&           VoteParameters                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UFancyVotingComponent::StartVoteMulticast(const struct FVoteParameters& VoteParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "StartVoteMulticast");

	Params::FancyVotingComponent_StartVoteMulticast Parms{};

	Parms.VoteParameters = std::move(VoteParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.StartVoteServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FVoteParameters&           VoteParameters                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UFancyVotingComponent::StartVoteServer(const struct FVoteParameters& VoteParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "StartVoteServer");

	Params::FancyVotingComponent_StartVoteServer Parms{};

	Parms.VoteParameters = std::move(VoteParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.VoteUpdated
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyVotingComponent::VoteUpdated(class APlayerState* PlayerState, bool NewVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "VoteUpdated");

	Params::FancyVotingComponent_VoteUpdated Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewVote = NewVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyVotingComponent.IsVotingActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyVotingComponent::IsVotingActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyVotingComponent", "IsVotingActive");

	Params::FancyVotingComponent_IsVotingActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.GripMotionControllerComponent.BP_IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGripMotionControllerComponent::BP_IsLocallyControlled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "BP_IsLocallyControlled");

	Params::GripMotionControllerComponent_BP_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.GripMotionControllerComponent.GetPhysicsVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector*                         AngularVelocity                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         LinearVelocity                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGripMotionControllerComponent::GetPhysicsVelocity(struct FVector* AngularVelocity, struct FVector* LinearVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "GetPhysicsVelocity");

	Params::GripMotionControllerComponent_GetPhysicsVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AngularVelocity != nullptr)
		*AngularVelocity = std::move(Parms.AngularVelocity);

	if (LinearVelocity != nullptr)
		*LinearVelocity = std::move(Parms.LinearVelocity);
}


// Function Backrooms.GripMotionControllerComponent.OnRep_ReplicatedControllerTransform
// (Native, Public)

void UGripMotionControllerComponent::OnRep_ReplicatedControllerTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "OnRep_ReplicatedControllerTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.GripMotionControllerComponent.Server_SendControllerTransform
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// const struct FTransform&                NewTransform                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGripMotionControllerComponent::Server_SendControllerTransform(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "Server_SendControllerTransform");

	Params::GripMotionControllerComponent_Server_SendControllerTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.GetMesh
// (Final, Native, Public)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AInspectableActor::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "GetMesh");

	Params::InspectableActor_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InspectableActor.SetCameraLocation
// (Final, Native, Public)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInspectableActor::SetCameraLocation(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetCameraLocation");

	Params::InspectableActor_SetCameraLocation Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.SetPlayerRef
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       Ref                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInspectableActor::SetPlayerRef(class ACharacter* Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetPlayerRef");

	Params::InspectableActor_SetPlayerRef Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.SetViewing
// (Final, Native, Public)

void AInspectableActor::SetViewing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetViewing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.BlockUsage
// (Final, Native, Public, BlueprintCallable)

void UInteractableComponent::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnRep_WasUsed
// (Final, Native, Public)

void UInteractableComponent::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void UInteractableComponent::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UInteractableComponent::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void UInteractableComponent::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::OnUsedServer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedServer");

	Params::InteractableComponent_OnUsedServer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.ResetUsage
// (Final, Native, Public, BlueprintCallable)

void UInteractableComponent::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableInterface.OnActorUsed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractableInterface::OnActorUsed(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InteractableInterface", "OnActorUsed");

	Params::InteractableInterface_OnActorUsed Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.AddToInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryItem*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::AddToInventory(class UInventoryItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddToInventory");

	Params::InventoryComponent_AddToInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.DropItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::DropItem(uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "DropItem");

	Params::InventoryComponent_DropItem Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.GetItemAtSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryItem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryItem* UInventoryComponent::GetItemAtSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetItemAtSlot");

	Params::InventoryComponent_GetItemAtSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.IsSlotEmpty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::IsSlotEmpty(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "IsSlotEmpty");

	Params::InventoryComponent_IsSlotEmpty Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.RemoveFromInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryItem*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::RemoveFromInventory(class UInventoryItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "RemoveFromInventory");

	Params::InventoryComponent_RemoveFromInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.SwapInventoryItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FirstIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::SwapInventoryItems(int32 FirstIdx, int32 SecondIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SwapInventoryItems");

	Params::InventoryComponent_SwapInventoryItems Parms{};

	Parms.FirstIdx = FirstIdx;
	Parms.SecondIdx = SecondIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ItemActor.CustomInventoryUse
// (Native, Event, Public, BlueprintEvent)

void AItemActor::CustomInventoryUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "CustomInventoryUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ItemActor.Use
// (Final, Native, Public, BlueprintCallable)

void AItemActor::Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.Level0Generator.Generate
// (Final, Native, Public, BlueprintCallable)

void ALevel0Generator::Generate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Level0Generator", "Generate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARBlueprintFunctionLibrary.CreateLiDarDot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLIDARDotStruct                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLIDARDotStruct ULIDARBlueprintFunctionLibrary::CreateLiDarDot(class UObject* caller, class UTextureRenderTarget2D* RenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIDARBlueprintFunctionLibrary", "CreateLiDarDot");

	Params::LIDARBlueprintFunctionLibrary_CreateLiDarDot Parms{};

	Parms.caller = caller;
	Parms.RenderTarget = RenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.LIDARBlueprintFunctionLibrary.FindCollisionUVSkeletalMesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector2D*                       UV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULIDARBlueprintFunctionLibrary::FindCollisionUVSkeletalMesh(const struct FHitResult& Hit, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIDARBlueprintFunctionLibrary", "FindCollisionUVSkeletalMesh");

	Params::LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;
}


// Function Backrooms.LIDARComponent.ShootAuto
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ULIDARComponent::ShootAuto()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootAuto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ShootGun
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ULIDARComponent::ShootGun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootGun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ShootReset
// (Final, Native, Public, BlueprintCallable)

void ULIDARComponent::ShootReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ScannerTrace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult ULIDARComponent::ScannerTrace(class UStaticMeshComponent* Mesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ScannerTrace");

	Params::LIDARComponent_ScannerTrace Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorCharacterMovement.DecreaseSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DecreaseAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::DecreaseSpeedMultiplier(float DecreaseAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "DecreaseSpeedMultiplier");

	Params::MapEditorCharacterMovement_DecreaseSpeedMultiplier Parms{};

	Parms.DecreaseAmount = DecreaseAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.EnterMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::EnterMovementMode(bool Enter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "EnterMovementMode");

	Params::MapEditorCharacterMovement_EnterMovementMode Parms{};

	Parms.Enter = Enter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.IncreaseSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   IncreaseAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::IncreaseSpeedMultiplier(float IncreaseAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "IncreaseSpeedMultiplier");

	Params::MapEditorCharacterMovement_IncreaseSpeedMultiplier Parms{};

	Parms.IncreaseAmount = IncreaseAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Init
// (Final, Native, Public, BlueprintCallable)

void UMapEditorCharacterMovement::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.LookUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::LookUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "LookUp");

	Params::MapEditorCharacterMovement_LookUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveForward");

	Params::MapEditorCharacterMovement_MoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveRight");

	Params::MapEditorCharacterMovement_MoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveUp");

	Params::MapEditorCharacterMovement_MoveUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Server_SetSpeedMultiplier
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::Server_SetSpeedMultiplier(float SpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Server_SetSpeedMultiplier");

	Params::MapEditorCharacterMovement_Server_SetSpeedMultiplier Parms{};

	Parms.SpeedMultiplier = SpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Turn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::Turn(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Turn");

	Params::MapEditorCharacterMovement_Turn Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.InMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorCharacterMovement::InMovementMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "InMovementMode");

	Params::MapEditorCharacterMovement_InMovementMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.DeleteActor
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::DeleteActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "DeleteActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.DeselectActor
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::DeselectActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "DeselectActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Grab
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Grab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Grab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Init
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.MouseTrace
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bHitGizmo                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebugLine                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UMapEditorHandlerComponent::MouseTrace(float Distance, bool* bHitGizmo, bool bDrawDebugLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "MouseTrace");

	Params::MapEditorHandlerComponent_MouseTrace Parms{};

	Parms.Distance = Distance;
	Parms.bDrawDebugLine = bDrawDebugLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHitGizmo != nullptr)
		*bHitGizmo = Parms.bHitGizmo;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.OnRep_CurrentActor
// (Final, Native, Protected)

void UMapEditorHandlerComponent::OnRep_CurrentActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "OnRep_CurrentActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Release
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_DeleteActor
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_DeleteActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_DeleteActor");

	Params::MapEditorHandlerComponent_Server_DeleteActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_ReplicateTransform
// (Net, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_ReplicateTransform(class AActor* Actor, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_ReplicateTransform");

	Params::MapEditorHandlerComponent_Server_ReplicateTransform Parms{};

	Parms.Actor = Actor;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_SpawnActor
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_SpawnActor(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_SpawnActor");

	Params::MapEditorHandlerComponent_Server_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_UnpossessToReturnPawn
// (Net, Native, Event, Protected, NetServer, NetValidate)

void UMapEditorHandlerComponent::Server_UnpossessToReturnPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_UnpossessToReturnPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetActor");

	Params::MapEditorHandlerComponent_SetActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetActorTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                NewTransform                                           (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetActorTransform(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetActorTransform");

	Params::MapEditorHandlerComponent_SetActorTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetReturnPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetReturnPawn(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetReturnPawn");

	Params::MapEditorHandlerComponent_SetReturnPawn Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetSnapAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMapEditorSnapping&        SnappingAmounts                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetSnapAmount(const struct FMapEditorSnapping& SnappingAmounts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetSnapAmount");

	Params::MapEditorHandlerComponent_SetSnapAmount Parms{};

	Parms.SnappingAmounts = std::move(SnappingAmounts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowMovement
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowRotation
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowScale
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SpawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SpawnActor(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SpawnActor");

	Params::MapEditorHandlerComponent_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Undo
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Undo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Undo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.UnpossessToReturnPawn
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::UnpossessToReturnPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "UnpossessToReturnPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.GetActorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorHandlerComponent::GetActorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetActorName");

	Params::MapEditorHandlerComponent_GetActorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetActorTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMapEditorHandlerComponent::GetActorTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetActorTransform");

	Params::MapEditorHandlerComponent_GetActorTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetGizmoType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGizmoType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGizmoType UMapEditorHandlerComponent::GetGizmoType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetGizmoType");

	Params::MapEditorHandlerComponent_GetGizmoType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetReplicationRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMapEditorHandlerComponent::GetReplicationRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetReplicationRate");

	Params::MapEditorHandlerComponent_GetReplicationRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetSnapAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMapEditorSnapping               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMapEditorSnapping UMapEditorHandlerComponent::GetSnapAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetSnapAmount");

	Params::MapEditorHandlerComponent_GetSnapAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.HasValidReturnPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorHandlerComponent::HasValidReturnPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "HasValidReturnPawn");

	Params::MapEditorHandlerComponent_HasValidReturnPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorInterface.OnDeleted
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnDeleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnDeleted");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnGrabbed
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnGrabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnGrabbed");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnMaterialLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FMapEditorItemMaterial&    MapEditorItemMaterial                                  (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IMapEditorInterface::OnMaterialLoaded(const struct FMapEditorItemMaterial& MapEditorItemMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnMaterialLoaded");

	Params::MapEditorInterface_OnMaterialLoaded Parms{};

	Parms.MapEditorItemMaterial = std::move(MapEditorItemMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorInterface.OnRelease
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnRelease");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnScaleChanged
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMapEditorInterface::OnScaleChanged(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnScaleChanged");

	Params::MapEditorInterface_OnScaleChanged Parms{};

	Parms.NewScale = std::move(NewScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorInterface.OnUndo
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnUndo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MapEditorInterface", "OnUndo");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorStatics.ClearMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorStatics::ClearMap(class AActor* WorldActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "ClearMap");

	Params::MapEditorStatics_ClearMap Parms{};

	Parms.WorldActor = WorldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.DeSerializeLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    JsonString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapEditorItems                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMapEditorItems UMapEditorStatics::DeSerializeLevel(const class FString& JsonString, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "DeSerializeLevel");

	Params::MapEditorStatics_DeSerializeLevel Parms{};

	Parms.JsonString = std::move(JsonString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.DoesMapExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::DoesMapExist(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "DoesMapExist");

	Params::MapEditorStatics_DoesMapExist Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.GetMapList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Directory                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCutLevelname                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowAllMaps                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UMapEditorStatics::GetMapList(class AActor* WorldActor, const class FString& Directory, bool bCutLevelname, bool bShowAllMaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "GetMapList");

	Params::MapEditorStatics_GetMapList Parms{};

	Parms.WorldActor = WorldActor;
	Parms.Directory = std::move(Directory);
	Parms.bCutLevelname = bCutLevelname;
	Parms.bShowAllMaps = bShowAllMaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.GetRealMapName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::GetRealMapName(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "GetRealMapName");

	Params::MapEditorStatics_GetRealMapName Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.LoadMapFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          FullMapName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::LoadMapFromFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& Extension, class FString* OutString, class FString* FullMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "LoadMapFromFile");

	Params::MapEditorStatics_LoadMapFromFile Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);
	Parms.Extension = std::move(Extension);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	if (FullMapName != nullptr)
		*FullMapName = std::move(Parms.FullMapName);

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.RemoveExtension
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::RemoveExtension(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "RemoveExtension");

	Params::MapEditorStatics_RemoveExtension Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SaveMapToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    StringToSave                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          FullMapName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::SaveMapToFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& StringToSave, class FString* FullMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SaveMapToFile");

	Params::MapEditorStatics_SaveMapToFile Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);
	Parms.StringToSave = std::move(StringToSave);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FullMapName != nullptr)
		*FullMapName = std::move(Parms.FullMapName);

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SerializeLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::SerializeLevel(class AActor* WorldActor, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SerializeLevel");

	Params::MapEditorStatics_SerializeLevel Parms{};

	Parms.WorldActor = WorldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SetMaterials
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMapEditorItemMaterial&    MapEditorItemMaterial                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMapEditorStatics::SetMaterials(const struct FMapEditorItemMaterial& MapEditorItemMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SetMaterials");

	Params::MapEditorStatics_SetMaterials Parms{};

	Parms.MapEditorItemMaterial = std::move(MapEditorItemMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.SpawnMapItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMapEditorItems&           MapItems                                               (Parm, NativeAccessSpecifierPublic)

void UMapEditorStatics::SpawnMapItems(class AActor* WorldActor, const struct FMapEditorItems& MapItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SpawnMapItems");

	Params::MapEditorStatics_SpawnMapItems Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapItems = std::move(MapItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.SpawnMapItemsFromJson
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    JsonString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorStatics::SpawnMapItemsFromJson(class AActor* WorldActor, const class FString& JsonString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SpawnMapItemsFromJson");

	Params::MapEditorStatics_SpawnMapItemsFromJson Parms{};

	Parms.WorldActor = WorldActor;
	Parms.JsonString = std::move(JsonString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MotionScannerComponent.EndWaveEvent
// (Event, Public, BlueprintEvent)

void UMotionScannerComponent::EndWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "EndWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MotionScannerComponent.SetNewScanDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   setDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionScannerComponent::SetNewScanDistance(float setDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "SetNewScanDistance");

	Params::MotionScannerComponent_SetNewScanDistance Parms{};

	Parms.setDistance = setDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MotionScannerComponent.StartWaveEvent
// (Event, Public, BlueprintEvent)

void UMotionScannerComponent::StartWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "StartWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.RadarPlayerComponent.EndWaveEvent
// (Event, Public, BlueprintEvent)

void URadarPlayerComponent::EndWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "EndWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.RadarPlayerComponent.SetNewScanDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   setDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadarPlayerComponent::SetNewScanDistance(float setDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "SetNewScanDistance");

	Params::RadarPlayerComponent_SetNewScanDistance Parms{};

	Parms.setDistance = setDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.RadarPlayerComponent.StartWaveEvent
// (Event, Public, BlueprintEvent)

void URadarPlayerComponent::StartWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "StartWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}

}

