#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OpenInputPlugin

#include "Basic.hpp"

#include "OpenInputPlugin_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class OpenInputPlugin.OpenInputFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOpenInputFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FillActionInfoFromRepContainer(class UObject* WorldContextObject, struct FBPOpenVRActionInfo& ActionInfo, struct FBPSkeletalRepContainer& TargetRepContainer);
	static void FillRepContainerFromActionInfo(struct FBPOpenVRActionInfo& ActionInfo, struct FBPSkeletalRepContainer& TargetRepContainer, EVRSkeletalReplicationType ReplicationType);
	static bool GetActionPose(struct FBPOpenVRActionInfo& Action, class UObject* WorldContextObject, bool bGetCompressedData, bool bGetGestureValues);
	static bool GetHandCurlAndSplayValues(EVRActionHand TargetHand, struct FBPOpenVRGesturePoseData& CurlAndSplayValuesOut, class UObject* WorldContextObject, const class FString& OptionalCustomActionName);
	static struct FTransform GetOpenVRBoneTransform(EVROpenInputBones BoneToGet, const struct FBPOpenVRActionInfo& HandSkeletalAction);
	static bool GetReferencePose(struct FBPOpenVRActionInfo& BlankActionToFill, const struct FBPOpenVRActionHandle& ActionHandleToQuery, class UObject* WorldContextObject, EVROpenInputReferencePose PoseTypeToRetreive);
	static bool GetSkeletalTrackingLevel(EVROpenInputSkeletalTrackingLevel* SkeletalTrackingLevelOut, EVRActionHand HandToRetreive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenInputFunctionLibrary">();
	}
	static class UOpenInputFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenInputFunctionLibrary>();
	}
};
static_assert(alignof(UOpenInputFunctionLibrary) == 0x000008, "Wrong alignment on UOpenInputFunctionLibrary");
static_assert(sizeof(UOpenInputFunctionLibrary) == 0x000028, "Wrong size on UOpenInputFunctionLibrary");

// Class OpenInputPlugin.OpenInputGestureDatabase
// 0x0010 (0x0040 - 0x0030)
class UOpenInputGestureDatabase final : public UDataAsset
{
public:
	TArray<struct FOpenInputGesture>              Gestures;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenInputGestureDatabase">();
	}
	static class UOpenInputGestureDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenInputGestureDatabase>();
	}
};
static_assert(alignof(UOpenInputGestureDatabase) == 0x000008, "Wrong alignment on UOpenInputGestureDatabase");
static_assert(sizeof(UOpenInputGestureDatabase) == 0x000040, "Wrong size on UOpenInputGestureDatabase");
static_assert(offsetof(UOpenInputGestureDatabase, Gestures) == 0x000030, "Member 'UOpenInputGestureDatabase::Gestures' has a wrong offset!");

// Class OpenInputPlugin.OpenInputSkeletalMeshComponent
// 0x0190 (0x1060 - 0x0ED0)
class UOpenInputSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bDetectGestures;                                   // 0x0EC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC9[0x7];                                      // 0x0EC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FName& GestureDetected, int32 GestureIndex, EVRActionHand ActionHandType)> OnNewGestureDetected; // 0x0ED0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FName& GestureEnded, int32 GestureIndex, EVRActionHand ActionHandType)> OnGestureEnded; // 0x0EE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOpenInputGestureDatabase*              GesturesDB;                                        // 0x0EF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetByControllerProfile;                        // 0x0EF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF9[0x3F];                                     // 0x0EF9(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBPOpenVRActionInfo>            HandSkeletalActions;                               // 0x0F38(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBPSkeletalRepContainer                LeftHandRep;                                       // 0x0F48(0x0058)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	struct FBPSkeletalRepContainer                RightHandRep;                                      // 0x0FA0(0x0058)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF8[0x48];                                     // 0x0FF8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReplicateSkeletalData;                            // 0x1040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothReplicatedSkeletalData;                     // 0x1041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1042[0x2];                                     // 0x1042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicationRateForSkeletalAnimations;              // 0x1044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVRSkeletalReplicationType                    ReplicationType;                                   // 0x1048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1049[0x17];                                    // 0x1049(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetFingerCurlAndSplayData(EVRActionHand TargetHand, struct FBPOpenVRGesturePoseData* OutFingerPoseData);
	bool K2_DetectCurrentPose(struct FBPOpenVRActionInfo* SkeletalAction, struct FOpenInputGesture* GestureOut);
	void NewControllerProfileLoaded();
	void OnRep_SkeletalTransformLeft();
	void OnRep_SkeletalTransformRight();
	void SaveCurrentPose(class FName RecordingName, bool bUseFingerCurlOnly, EVRActionHand HandToSave);
	void Server_SendSkeletalTransforms(const struct FBPSkeletalRepContainer& SkeletalInfo);
	void SetDetectGestures(bool bNewDetectGestures);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenInputSkeletalMeshComponent">();
	}
	static class UOpenInputSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenInputSkeletalMeshComponent>();
	}
};
static_assert(alignof(UOpenInputSkeletalMeshComponent) == 0x000010, "Wrong alignment on UOpenInputSkeletalMeshComponent");
static_assert(sizeof(UOpenInputSkeletalMeshComponent) == 0x001060, "Wrong size on UOpenInputSkeletalMeshComponent");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, bDetectGestures) == 0x000EC8, "Member 'UOpenInputSkeletalMeshComponent::bDetectGestures' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, OnNewGestureDetected) == 0x000ED0, "Member 'UOpenInputSkeletalMeshComponent::OnNewGestureDetected' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, OnGestureEnded) == 0x000EE0, "Member 'UOpenInputSkeletalMeshComponent::OnGestureEnded' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, GesturesDB) == 0x000EF0, "Member 'UOpenInputSkeletalMeshComponent::GesturesDB' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, bOffsetByControllerProfile) == 0x000EF8, "Member 'UOpenInputSkeletalMeshComponent::bOffsetByControllerProfile' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, HandSkeletalActions) == 0x000F38, "Member 'UOpenInputSkeletalMeshComponent::HandSkeletalActions' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, LeftHandRep) == 0x000F48, "Member 'UOpenInputSkeletalMeshComponent::LeftHandRep' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, RightHandRep) == 0x000FA0, "Member 'UOpenInputSkeletalMeshComponent::RightHandRep' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, bReplicateSkeletalData) == 0x001040, "Member 'UOpenInputSkeletalMeshComponent::bReplicateSkeletalData' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, bSmoothReplicatedSkeletalData) == 0x001041, "Member 'UOpenInputSkeletalMeshComponent::bSmoothReplicatedSkeletalData' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, ReplicationRateForSkeletalAnimations) == 0x001044, "Member 'UOpenInputSkeletalMeshComponent::ReplicationRateForSkeletalAnimations' has a wrong offset!");
static_assert(offsetof(UOpenInputSkeletalMeshComponent, ReplicationType) == 0x001048, "Member 'UOpenInputSkeletalMeshComponent::ReplicationType' has a wrong offset!");

// Class OpenInputPlugin.OpenInputAnimInstance
// 0x0790 (0x0A50 - 0x02C0)
class UOpenInputAnimInstance final : public UAnimInstance
{
public:
	class UOpenInputSkeletalMeshComponent*        OwningMesh;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x790];                                    // 0x02C0(0x0790)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCustomBoneMapping(struct FBPSkeletalMappingData& SkeletalMappingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenInputAnimInstance">();
	}
	static class UOpenInputAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenInputAnimInstance>();
	}
};
static_assert(alignof(UOpenInputAnimInstance) == 0x000010, "Wrong alignment on UOpenInputAnimInstance");
static_assert(sizeof(UOpenInputAnimInstance) == 0x000A50, "Wrong size on UOpenInputAnimInstance");
static_assert(offsetof(UOpenInputAnimInstance, OwningMesh) == 0x0002B8, "Member 'UOpenInputAnimInstance::OwningMesh' has a wrong offset!");

}

