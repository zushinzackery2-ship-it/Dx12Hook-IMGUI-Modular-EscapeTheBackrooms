#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Backrooms

#include "Basic.hpp"

#include "XShip_structs.hpp"
#include "InteractiveToolsFramework_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"
#include "Backrooms_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AdvancedSessions_classes.hpp"
#include "SlateCore_structs.hpp"
#include "HeadMountedDisplay_classes.hpp"


namespace SDK
{

// Class Backrooms.InteractableActor
// 0x0028 (0x0248 - 0x0220)
class AInteractableActor : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             UsedSound;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsable;                                          // 0x0240(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WasUsed;                                           // 0x0241(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAimAssist;                                  // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockUsage();
	void OnBeginHighlight();
	void OnEndHighlight();
	void OnInteractStartedLocal();
	void OnRep_IsUsable();
	void OnRep_WasUsed();
	void OnUsedAll();
	void OnUsedMulticast();
	void OnUsedNotify();
	void OnUsedServer();
	void ResetUsage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableActor">();
	}
	static class AInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableActor>();
	}
};
static_assert(alignof(AInteractableActor) == 0x000008, "Wrong alignment on AInteractableActor");
static_assert(sizeof(AInteractableActor) == 0x000248, "Wrong size on AInteractableActor");
static_assert(offsetof(AInteractableActor, SceneComponent) == 0x000228, "Member 'AInteractableActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AInteractableActor, StaticMesh) == 0x000230, "Member 'AInteractableActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(AInteractableActor, UsedSound) == 0x000238, "Member 'AInteractableActor::UsedSound' has a wrong offset!");
static_assert(offsetof(AInteractableActor, IsUsable) == 0x000240, "Member 'AInteractableActor::IsUsable' has a wrong offset!");
static_assert(offsetof(AInteractableActor, WasUsed) == 0x000241, "Member 'AInteractableActor::WasUsed' has a wrong offset!");
static_assert(offsetof(AInteractableActor, bShouldAimAssist) == 0x000242, "Member 'AInteractableActor::bShouldAimAssist' has a wrong offset!");

// Class Backrooms.PushableActor
// 0x0008 (0x0250 - 0x0248)
class APushableActor : public AInteractableActor
{
public:
	float                                         Density;                                           // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetClosesPoint(class AActor* InActor);
	TArray<struct FVector> GetForwardBoundingPoints(bool InInvert);
	TArray<struct FVector> GetRightBoundingPoints(bool InInvert);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushableActor">();
	}
	static class APushableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APushableActor>();
	}
};
static_assert(alignof(APushableActor) == 0x000008, "Wrong alignment on APushableActor");
static_assert(sizeof(APushableActor) == 0x000250, "Wrong size on APushableActor");
static_assert(offsetof(APushableActor, Density) == 0x000248, "Member 'APushableActor::Density' has a wrong offset!");

// Class Backrooms.AI_ObjectWC
// 0x0000 (0x0028 - 0x0028)
class UAI_ObjectWC final : public UObject
{
public:
	void FinishExecute();
	bool GetWeight();
	void OnUpdate();
	void StartExecute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AI_ObjectWC">();
	}
	static class UAI_ObjectWC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAI_ObjectWC>();
	}
};
static_assert(alignof(UAI_ObjectWC) == 0x000008, "Wrong alignment on UAI_ObjectWC");
static_assert(sizeof(UAI_ObjectWC) == 0x000028, "Wrong size on UAI_ObjectWC");

// Class Backrooms.MissionData
// 0x0040 (0x0068 - 0x0028)
class UMissionData final : public UObject
{
public:
	class FString                                 TargetEscapeLevel;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCompleted;                                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayerDeaths;                                      // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EntitySightings;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LowSanityAmount;                                   // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         XPPenalty;                                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LevelBaseXP;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelTimeLimit;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MissionDataRowName;                                // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddEntitySighting();
	void AddLowSanityAmount();
	void AddPlayerDeath();
	void SetTimeCompleted(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionData">();
	}
	static class UMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionData>();
	}
};
static_assert(alignof(UMissionData) == 0x000008, "Wrong alignment on UMissionData");
static_assert(sizeof(UMissionData) == 0x000068, "Wrong size on UMissionData");
static_assert(offsetof(UMissionData, TargetEscapeLevel) == 0x000028, "Member 'UMissionData::TargetEscapeLevel' has a wrong offset!");
static_assert(offsetof(UMissionData, TimeCompleted) == 0x000038, "Member 'UMissionData::TimeCompleted' has a wrong offset!");
static_assert(offsetof(UMissionData, PlayerDeaths) == 0x00003C, "Member 'UMissionData::PlayerDeaths' has a wrong offset!");
static_assert(offsetof(UMissionData, EntitySightings) == 0x000040, "Member 'UMissionData::EntitySightings' has a wrong offset!");
static_assert(offsetof(UMissionData, LowSanityAmount) == 0x000044, "Member 'UMissionData::LowSanityAmount' has a wrong offset!");
static_assert(offsetof(UMissionData, XPPenalty) == 0x000048, "Member 'UMissionData::XPPenalty' has a wrong offset!");
static_assert(offsetof(UMissionData, LevelBaseXP) == 0x00004C, "Member 'UMissionData::LevelBaseXP' has a wrong offset!");
static_assert(offsetof(UMissionData, LevelTimeLimit) == 0x000050, "Member 'UMissionData::LevelTimeLimit' has a wrong offset!");
static_assert(offsetof(UMissionData, MissionDataRowName) == 0x000058, "Member 'UMissionData::MissionDataRowName' has a wrong offset!");

// Class Backrooms.AimAssistComponent
// 0x0108 (0x01B8 - 0x00B0)
class UAimAssistComponent : public UActorComponent
{
public:
	TMap<class FName, struct FAimAssistSettings>  Configuration;                                     // 0x00B0(0x0050)(Edit, BlueprintVisible, SimpleDisplay, NativeAccessSpecifierPublic)
	ECollisionSelectionMethod                     CollisionMethod;                                   // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  CollisionProfile;                                  // 0x0104(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAimAssistCastType                            TargetSeekerCastType;                              // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSphereCastCount;                                // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistRadius;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConeTraceSubdivision;                              // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearClipDistance;                                  // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarClipDistance;                                   // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreferredBone;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UAimAssistComponent* Sender, const struct FAimAssistTarget& AimAssistTarget)> TargetFound; // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UAimAssistComponent* Sender, const struct FAimAssistTarget& AimAssistTarget)> TargetLost; // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCreateReticle;                                    // 0x0150(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFancyCharacter*                        Character;                                         // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x48];                                     // 0x0170(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCanMove();
	void OnAimAssistDeviceEnabled(bool IsGamepad);
	const struct FRotator ProcessAimAssist(const float DeltaTime);

	struct FAimAssistTarget GetCurrentTargetOrDefault() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistComponent">();
	}
	static class UAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistComponent>();
	}
};
static_assert(alignof(UAimAssistComponent) == 0x000008, "Wrong alignment on UAimAssistComponent");
static_assert(sizeof(UAimAssistComponent) == 0x0001B8, "Wrong size on UAimAssistComponent");
static_assert(offsetof(UAimAssistComponent, Configuration) == 0x0000B0, "Member 'UAimAssistComponent::Configuration' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, CollisionMethod) == 0x000100, "Member 'UAimAssistComponent::CollisionMethod' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, CollisionChannel) == 0x000101, "Member 'UAimAssistComponent::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, CollisionProfile) == 0x000104, "Member 'UAimAssistComponent::CollisionProfile' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, TargetSeekerCastType) == 0x00010C, "Member 'UAimAssistComponent::TargetSeekerCastType' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, MaxSphereCastCount) == 0x000110, "Member 'UAimAssistComponent::MaxSphereCastCount' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, AimAssistRadius) == 0x000114, "Member 'UAimAssistComponent::AimAssistRadius' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, ConeAngle) == 0x000118, "Member 'UAimAssistComponent::ConeAngle' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, ConeTraceSubdivision) == 0x00011C, "Member 'UAimAssistComponent::ConeTraceSubdivision' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, NearClipDistance) == 0x000120, "Member 'UAimAssistComponent::NearClipDistance' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, FarClipDistance) == 0x000124, "Member 'UAimAssistComponent::FarClipDistance' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, PreferredBone) == 0x000128, "Member 'UAimAssistComponent::PreferredBone' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, TargetFound) == 0x000130, "Member 'UAimAssistComponent::TargetFound' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, TargetLost) == 0x000140, "Member 'UAimAssistComponent::TargetLost' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, bCreateReticle) == 0x000150, "Member 'UAimAssistComponent::bCreateReticle' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, PlayerController) == 0x000158, "Member 'UAimAssistComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, Character) == 0x000160, "Member 'UAimAssistComponent::Character' has a wrong offset!");
static_assert(offsetof(UAimAssistComponent, CharacterMovement) == 0x000168, "Member 'UAimAssistComponent::CharacterMovement' has a wrong offset!");

// Class Backrooms.BackroomsBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBackroomsBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float AddXP(float xpToAdd);
	static bool CanNavigationReachPoint(class APawn* Pawn, const struct FVector& StartLocation, const struct FVector& EndLocation);
	static void ClearCharacterFloor(class ACharacter* Character);
	static void ClearVoice();
	static void DeleteInputSettings();
	static class FName DetectCurrentGesture(const TArray<float>& PoseFingerCurls, class UOpenInputGestureDatabase* GesturesDB);
	static TArray<class FString> GetAllSaveGameSlotNames();
	static struct FDateTime GetDateFromSeconds(int32 Seconds);
	static int32 GetIndexOfClosestSplinePoint(class USplineComponent* SplineComponent, const struct FVector& WorldLocation);
	static TArray<class APlayerState*> GetPlayerStateArray(class AGameStateBase* GameState);
	static TArray<class FString> GetSaveGameSlotsByType(const class FString& Prefix);
	static TArray<struct FVector> GetSplinePoints(class USplineComponent* SplineComponent);
	static int32 GetSystemTimeSeconds(const struct FDateTime& DateTime);
	static float GetViewDistanceScale();
	static bool IsNoHMDMode();
	static void K2_IsTearingDown(class UObject* caller, bool* isTearingDown);
	static float LoadXP();
	static void PatchMissingInputActions(const TArray<struct FInputActionKeyMapping>& NewActions);
	static class UTimelineComponent* PlayRate(class UTimelineComponent* Timeline, float Sec);
	static void ReloadBindings();
	static void ResetInputSettings();
	static void ResetWorldTime(const class AGameMode* GameMode);
	static void SaveToClipboard(const class FString& ToClipboard);
	static void SetCurrentLevelLogs(const class FString& LevelName);
	static void SetLogValue(const class FString& Key, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackroomsBPFunctionLibrary">();
	}
	static class UBackroomsBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackroomsBPFunctionLibrary>();
	}
};
static_assert(alignof(UBackroomsBPFunctionLibrary) == 0x000008, "Wrong alignment on UBackroomsBPFunctionLibrary");
static_assert(sizeof(UBackroomsBPFunctionLibrary) == 0x000028, "Wrong size on UBackroomsBPFunctionLibrary");

// Class Backrooms.MapEditorCharacter
// 0x0000 (0x04C0 - 0x04C0)
class AMapEditorCharacter final : public ACharacter
{
public:
	class UCameraComponent*                       CameraComponent;                                   // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorCharacter">();
	}
	static class AMapEditorCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapEditorCharacter>();
	}
};
static_assert(alignof(AMapEditorCharacter) == 0x000010, "Wrong alignment on AMapEditorCharacter");
static_assert(sizeof(AMapEditorCharacter) == 0x0004C0, "Wrong size on AMapEditorCharacter");
static_assert(offsetof(AMapEditorCharacter, CameraComponent) == 0x0004B8, "Member 'AMapEditorCharacter::CameraComponent' has a wrong offset!");

// Class Backrooms.BoatComponent
// 0x00D8 (0x0188 - 0x00B0)
class UBoatComponent final : public UActorComponent
{
public:
	TArray<struct FXShipFloater>                  XShipFloaters;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FXShipEngine>                   XShipEngines;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WaterDensity;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDensity;                                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterWorldZ;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomShipBoundsRadius;                           // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShipBoundsRadius;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWaterLinearDamping;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutWaterLinearDamping;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWaterAngularDamping;                             // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutWaterAngularDamping;                            // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAccelerationSpeed;                         // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementBrakingSpeed;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSideDampingSpeed;                          // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientRotationToMovement;                         // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMoveBackwardWithOrientRotation;                // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToleranceForMoveBackwardWithOrientRotation;        // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeed;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAccelerationSpeed;                         // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationBrakingSpeed;                              // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiplyRotationBySpeed;                          // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedForMaxRotation;                               // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStabilization;                              // 0x011C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStabilizationInAir;                         // 0x011D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InAirAngularStabilizationSpeed;                    // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAirAngularStabilizationDamping;                  // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularStabilizationSpeed;                         // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularStabilizationDamping;                       // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearStabilizationDamping;                        // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncMovement;                                     // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendPacketInterval;                                // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientSyncSpeed;                                   // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceReplication;                                 // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepXShipMovement                      RepXShipMovement;                                  // 0x0144(0x0030)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SendPacketIntervalLocal;                           // 0x0174(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MovementInput;                                     // 0x0178(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInput;                                     // 0x0184(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableAllEngines();
	void DisableAllFloaters();
	void EnableAllEngines();
	void EnableAllFloaters();
	float GetShipBoundsRadius();
	class ABoatPawn* GetXShipPawn();
	bool IsEngineInWater();
	void Server_PassMovementInfo(const struct FRepXShipMovement& NewRepXShipMovement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoatComponent">();
	}
	static class UBoatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoatComponent>();
	}
};
static_assert(alignof(UBoatComponent) == 0x000008, "Wrong alignment on UBoatComponent");
static_assert(sizeof(UBoatComponent) == 0x000188, "Wrong size on UBoatComponent");
static_assert(offsetof(UBoatComponent, XShipFloaters) == 0x0000B0, "Member 'UBoatComponent::XShipFloaters' has a wrong offset!");
static_assert(offsetof(UBoatComponent, XShipEngines) == 0x0000C0, "Member 'UBoatComponent::XShipEngines' has a wrong offset!");
static_assert(offsetof(UBoatComponent, WaterDensity) == 0x0000D0, "Member 'UBoatComponent::WaterDensity' has a wrong offset!");
static_assert(offsetof(UBoatComponent, AirDensity) == 0x0000D4, "Member 'UBoatComponent::AirDensity' has a wrong offset!");
static_assert(offsetof(UBoatComponent, WaterWorldZ) == 0x0000D8, "Member 'UBoatComponent::WaterWorldZ' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bCustomShipBoundsRadius) == 0x0000DC, "Member 'UBoatComponent::bCustomShipBoundsRadius' has a wrong offset!");
static_assert(offsetof(UBoatComponent, ShipBoundsRadius) == 0x0000E0, "Member 'UBoatComponent::ShipBoundsRadius' has a wrong offset!");
static_assert(offsetof(UBoatComponent, InWaterLinearDamping) == 0x0000E4, "Member 'UBoatComponent::InWaterLinearDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, OutWaterLinearDamping) == 0x0000E8, "Member 'UBoatComponent::OutWaterLinearDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, InWaterAngularDamping) == 0x0000EC, "Member 'UBoatComponent::InWaterAngularDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, OutWaterAngularDamping) == 0x0000F0, "Member 'UBoatComponent::OutWaterAngularDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, MovementAccelerationSpeed) == 0x0000F4, "Member 'UBoatComponent::MovementAccelerationSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, MovementBrakingSpeed) == 0x0000F8, "Member 'UBoatComponent::MovementBrakingSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, MovementSideDampingSpeed) == 0x0000FC, "Member 'UBoatComponent::MovementSideDampingSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bOrientRotationToMovement) == 0x000100, "Member 'UBoatComponent::bOrientRotationToMovement' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bCanMoveBackwardWithOrientRotation) == 0x000101, "Member 'UBoatComponent::bCanMoveBackwardWithOrientRotation' has a wrong offset!");
static_assert(offsetof(UBoatComponent, ToleranceForMoveBackwardWithOrientRotation) == 0x000104, "Member 'UBoatComponent::ToleranceForMoveBackwardWithOrientRotation' has a wrong offset!");
static_assert(offsetof(UBoatComponent, MaxRotationSpeed) == 0x000108, "Member 'UBoatComponent::MaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, RotationAccelerationSpeed) == 0x00010C, "Member 'UBoatComponent::RotationAccelerationSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, RotationBrakingSpeed) == 0x000110, "Member 'UBoatComponent::RotationBrakingSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bMultiplyRotationBySpeed) == 0x000114, "Member 'UBoatComponent::bMultiplyRotationBySpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, SpeedForMaxRotation) == 0x000118, "Member 'UBoatComponent::SpeedForMaxRotation' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bEnableStabilization) == 0x00011C, "Member 'UBoatComponent::bEnableStabilization' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bEnableStabilizationInAir) == 0x00011D, "Member 'UBoatComponent::bEnableStabilizationInAir' has a wrong offset!");
static_assert(offsetof(UBoatComponent, InAirAngularStabilizationSpeed) == 0x000120, "Member 'UBoatComponent::InAirAngularStabilizationSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, InAirAngularStabilizationDamping) == 0x000124, "Member 'UBoatComponent::InAirAngularStabilizationDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, AngularStabilizationSpeed) == 0x000128, "Member 'UBoatComponent::AngularStabilizationSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, AngularStabilizationDamping) == 0x00012C, "Member 'UBoatComponent::AngularStabilizationDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, LinearStabilizationDamping) == 0x000130, "Member 'UBoatComponent::LinearStabilizationDamping' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bSyncMovement) == 0x000134, "Member 'UBoatComponent::bSyncMovement' has a wrong offset!");
static_assert(offsetof(UBoatComponent, SendPacketInterval) == 0x000138, "Member 'UBoatComponent::SendPacketInterval' has a wrong offset!");
static_assert(offsetof(UBoatComponent, ClientSyncSpeed) == 0x00013C, "Member 'UBoatComponent::ClientSyncSpeed' has a wrong offset!");
static_assert(offsetof(UBoatComponent, bForceReplication) == 0x000140, "Member 'UBoatComponent::bForceReplication' has a wrong offset!");
static_assert(offsetof(UBoatComponent, RepXShipMovement) == 0x000144, "Member 'UBoatComponent::RepXShipMovement' has a wrong offset!");
static_assert(offsetof(UBoatComponent, SendPacketIntervalLocal) == 0x000174, "Member 'UBoatComponent::SendPacketIntervalLocal' has a wrong offset!");
static_assert(offsetof(UBoatComponent, MovementInput) == 0x000178, "Member 'UBoatComponent::MovementInput' has a wrong offset!");
static_assert(offsetof(UBoatComponent, RotationInput) == 0x000184, "Member 'UBoatComponent::RotationInput' has a wrong offset!");

// Class Backrooms.FancyCharacter
// 0x0060 (0x0520 - 0x04C0)
class AFancyCharacter : public ACharacter
{
public:
	bool                                          CanMove;                                           // 0x04B8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceLength;                                       // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x04C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsingItem;                                       // 0x04C1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLeaning;                                         // 0x04C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanCollide;                                        // 0x04C3(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapOnly;                                     // 0x04C4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraShake;                                // 0x04C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAimAssist;                                  // 0x04C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C7[0x1];                                      // 0x04C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ADroppedItem*                           CurrentFocusedItem;                                // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInteractablePawn*                      CurrentInteractingPawn;                            // 0x04D0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APushableActor*                         CurrentPushableActor;                              // 0x04D8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFancyCameraComponent*                  CameraComponent;                                   // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFancySpringArmComponent*               SpringArm;                                         // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Arms;                                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFancyCarrySystemCarrier*               CarrySystem;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CurrentInteractableActor;                          // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x18];                                     // 0x0508(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeCrosshairVisibility(bool IsVisible);
	void CheckPawn();
	void CheckSpawnedItems();
	void HideItem(bool IsVisible);
	void Interact(class AActor* Actor);
	void InteractCallBackVR(class AActor* Actor);
	void KillPlayer(bool bResetInteractable);
	void OnRep_CanCollide();
	void OnRep_IsOverlapOnly();
	void OnSanityUpdate(float Sanity);
	void SetCanCollide(bool ShouldCollide);
	void SetIsOverlapOnly(bool ShouldOverlapOnly);
	void StopPushing();
	void ToggleBlur(bool ShouldBlur);
	void TogglePlayerLegs(bool IsHidden);
	void TogglePlayerVisibility(bool IsHidden);
	void TryPickup();

	class AActor* GetCurrentInteractableActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyCharacter">();
	}
	static class AFancyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFancyCharacter>();
	}
};
static_assert(alignof(AFancyCharacter) == 0x000010, "Wrong alignment on AFancyCharacter");
static_assert(sizeof(AFancyCharacter) == 0x000520, "Wrong size on AFancyCharacter");
static_assert(offsetof(AFancyCharacter, CanMove) == 0x0004B8, "Member 'AFancyCharacter::CanMove' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, TraceLength) == 0x0004BC, "Member 'AFancyCharacter::TraceLength' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, bIsDead) == 0x0004C0, "Member 'AFancyCharacter::bIsDead' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, IsUsingItem) == 0x0004C1, "Member 'AFancyCharacter::IsUsingItem' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, IsLeaning) == 0x0004C2, "Member 'AFancyCharacter::IsLeaning' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CanCollide) == 0x0004C3, "Member 'AFancyCharacter::CanCollide' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, IsOverlapOnly) == 0x0004C4, "Member 'AFancyCharacter::IsOverlapOnly' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, bEnableCameraShake) == 0x0004C5, "Member 'AFancyCharacter::bEnableCameraShake' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, bEnableAimAssist) == 0x0004C6, "Member 'AFancyCharacter::bEnableAimAssist' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CurrentFocusedItem) == 0x0004C8, "Member 'AFancyCharacter::CurrentFocusedItem' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CurrentInteractingPawn) == 0x0004D0, "Member 'AFancyCharacter::CurrentInteractingPawn' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CurrentPushableActor) == 0x0004D8, "Member 'AFancyCharacter::CurrentPushableActor' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CameraComponent) == 0x0004E0, "Member 'AFancyCharacter::CameraComponent' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, SpringArm) == 0x0004E8, "Member 'AFancyCharacter::SpringArm' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, Arms) == 0x0004F0, "Member 'AFancyCharacter::Arms' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CarrySystem) == 0x0004F8, "Member 'AFancyCharacter::CarrySystem' has a wrong offset!");
static_assert(offsetof(AFancyCharacter, CurrentInteractableActor) == 0x000500, "Member 'AFancyCharacter::CurrentInteractableActor' has a wrong offset!");

// Class Backrooms.InteractablePawn
// 0x0080 (0x0300 - 0x0280)
class AInteractablePawn : public APawn
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsable;                                          // 0x0298(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WasUsed;                                           // 0x0299(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CachedRotation;                                    // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldCameraShake;                                // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractDelay;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VROffset;                                          // 0x02B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldCheck;                                       // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideCursor;                                        // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldHidePlayer;                                  // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldStopMovement;                                // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             InteractingPlayer;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      InteractingController;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           IdleShake;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAimAssist;                                  // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0xF];                                      // 0x02D9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableCameraComponent*           InteractableCameraComponent;                       // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionControllerComponent*             LeftGrip;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionControllerComponent*             RightGrip;                                         // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BlockUsage();
	void OnAttemptUse(bool CanUse);
	void OnHiddenPossess(class ACharacter* Character);
	void OnPossess();
	void OnRep_IsUsable();
	void OnRep_WasUsed();
	void OnStartInteracting(class ACharacter* Character);
	void OnStopInteracting();
	void OnUnPossess();
	void OnUsedAll();
	void OnUsedMulticast();
	void OnUsedNotify();
	void OnUsedServer(class ACharacter* Character);
	void OnVRPossess(bool bPossess);
	void ResetUsage();
	void SetCameraPostProcessing(class ACharacter* Character);
	void SetUsingVR(class ACharacter* Character, bool bPossess);
	void ToggleMouse(bool bHide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractablePawn">();
	}
	static class AInteractablePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractablePawn>();
	}
};
static_assert(alignof(AInteractablePawn) == 0x000008, "Wrong alignment on AInteractablePawn");
static_assert(sizeof(AInteractablePawn) == 0x000300, "Wrong size on AInteractablePawn");
static_assert(offsetof(AInteractablePawn, SceneComponent) == 0x000288, "Member 'AInteractablePawn::SceneComponent' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, StaticMesh) == 0x000290, "Member 'AInteractablePawn::StaticMesh' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, IsUsable) == 0x000298, "Member 'AInteractablePawn::IsUsable' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, WasUsed) == 0x000299, "Member 'AInteractablePawn::WasUsed' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, CachedRotation) == 0x00029C, "Member 'AInteractablePawn::CachedRotation' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, bShouldCameraShake) == 0x0002A8, "Member 'AInteractablePawn::bShouldCameraShake' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, InteractDelay) == 0x0002AC, "Member 'AInteractablePawn::InteractDelay' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, VROffset) == 0x0002B0, "Member 'AInteractablePawn::VROffset' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, ShouldCheck) == 0x0002BC, "Member 'AInteractablePawn::ShouldCheck' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, HideCursor) == 0x0002BD, "Member 'AInteractablePawn::HideCursor' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, ShouldHidePlayer) == 0x0002BE, "Member 'AInteractablePawn::ShouldHidePlayer' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, ShouldStopMovement) == 0x0002BF, "Member 'AInteractablePawn::ShouldStopMovement' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, InteractingPlayer) == 0x0002C0, "Member 'AInteractablePawn::InteractingPlayer' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, InteractingController) == 0x0002C8, "Member 'AInteractablePawn::InteractingController' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, IdleShake) == 0x0002D0, "Member 'AInteractablePawn::IdleShake' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, bShouldAimAssist) == 0x0002D8, "Member 'AInteractablePawn::bShouldAimAssist' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, InteractableCameraComponent) == 0x0002E8, "Member 'AInteractablePawn::InteractableCameraComponent' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, LeftGrip) == 0x0002F0, "Member 'AInteractablePawn::LeftGrip' has a wrong offset!");
static_assert(offsetof(AInteractablePawn, RightGrip) == 0x0002F8, "Member 'AInteractablePawn::RightGrip' has a wrong offset!");

// Class Backrooms.PlayerStatsComponent
// 0x0010 (0x00C0 - 0x00B0)
class UPlayerStatsComponent final : public UActorComponent
{
public:
	TArray<struct FCollectible>                   Collectibles;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatsComponent">();
	}
	static class UPlayerStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStatsComponent>();
	}
};
static_assert(alignof(UPlayerStatsComponent) == 0x000008, "Wrong alignment on UPlayerStatsComponent");
static_assert(sizeof(UPlayerStatsComponent) == 0x0000C0, "Wrong size on UPlayerStatsComponent");
static_assert(offsetof(UPlayerStatsComponent, Collectibles) == 0x0000B0, "Member 'UPlayerStatsComponent::Collectibles' has a wrong offset!");

// Class Backrooms.BoatPawn
// 0x0020 (0x0320 - 0x0300)
class ABoatPawn : public AInteractablePawn
{
public:
	class UBoxComponent*                          RootBoxComponent;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoatComponent*                         BoatComponent;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BoatMaskMesh;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddRotationInput(float ScaleValue);
	float GetWaterDensity(const struct FVector2D& InLocation);
	struct FVector GetWaterNormal(const struct FVector2D& InLocation);
	float GetWaterWorldZ(const struct FVector2D& InLocation);
	class UBoatComponent* GetXShipComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoatPawn">();
	}
	static class ABoatPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoatPawn>();
	}
};
static_assert(alignof(ABoatPawn) == 0x000008, "Wrong alignment on ABoatPawn");
static_assert(sizeof(ABoatPawn) == 0x000320, "Wrong size on ABoatPawn");
static_assert(offsetof(ABoatPawn, RootBoxComponent) == 0x000300, "Member 'ABoatPawn::RootBoxComponent' has a wrong offset!");
static_assert(offsetof(ABoatPawn, ArrowComponent) == 0x000308, "Member 'ABoatPawn::ArrowComponent' has a wrong offset!");
static_assert(offsetof(ABoatPawn, BoatComponent) == 0x000310, "Member 'ABoatPawn::BoatComponent' has a wrong offset!");
static_assert(offsetof(ABoatPawn, BoatMaskMesh) == 0x000318, "Member 'ABoatPawn::BoatMaskMesh' has a wrong offset!");

// Class Backrooms.DryLandVolume
// 0x0000 (0x0258 - 0x0258)
class ADryLandVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DryLandVolume">();
	}
	static class ADryLandVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADryLandVolume>();
	}
};
static_assert(alignof(ADryLandVolume) == 0x000008, "Wrong alignment on ADryLandVolume");
static_assert(sizeof(ADryLandVolume) == 0x000258, "Wrong size on ADryLandVolume");

// Class Backrooms.ClientInteractableActor
// 0x0000 (0x0248 - 0x0248)
class AClientInteractableActor : public AInteractableActor
{
public:
	void OnUsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientInteractableActor">();
	}
	static class AClientInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClientInteractableActor>();
	}
};
static_assert(alignof(AClientInteractableActor) == 0x000008, "Wrong alignment on AClientInteractableActor");
static_assert(sizeof(AClientInteractableActor) == 0x000248, "Wrong size on AClientInteractableActor");

// Class Backrooms.ClientInteractablePawn
// 0x0000 (0x0300 - 0x0300)
class AClientInteractablePawn final : public AInteractablePawn
{
public:
	void OnUsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientInteractablePawn">();
	}
	static class AClientInteractablePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClientInteractablePawn>();
	}
};
static_assert(alignof(AClientInteractablePawn) == 0x000008, "Wrong alignment on AClientInteractablePawn");
static_assert(sizeof(AClientInteractablePawn) == 0x000300, "Wrong size on AClientInteractablePawn");

// Class Backrooms.FancyCarrySystemCarrier
// 0x0030 (0x0230 - 0x0200)
class UFancyCarrySystemCarrier final : public USceneComponent
{
public:
	class UFancyCarrySystemCarryable*             CurrentCarryable;                                  // 0x01F8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFancyCarrySystemCarryable*             CurrentFocusedCarryable;                           // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UFancyCarrySystemCarryable* Carryable)> OnCarryStarted;      // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFancyCarrySystemCarryable* Carryable)> OnCarryStopped;      // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceDropCarry();
	void OnRep_CurrentCarryable(class UFancyCarrySystemCarryable* PreviousCarryable);
	void StartCarry(class UFancyCarrySystemCarryable* Carryable);
	void StopCarry();

	class UFancyCarrySystemCarryable* GetCurrentCarryable() const;
	class UFancyCarrySystemCarryable* GetCurrentFocusedCarryable() const;
	bool IsCarrying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyCarrySystemCarrier">();
	}
	static class UFancyCarrySystemCarrier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyCarrySystemCarrier>();
	}
};
static_assert(alignof(UFancyCarrySystemCarrier) == 0x000010, "Wrong alignment on UFancyCarrySystemCarrier");
static_assert(sizeof(UFancyCarrySystemCarrier) == 0x000230, "Wrong size on UFancyCarrySystemCarrier");
static_assert(offsetof(UFancyCarrySystemCarrier, CurrentCarryable) == 0x0001F8, "Member 'UFancyCarrySystemCarrier::CurrentCarryable' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarrier, CurrentFocusedCarryable) == 0x000200, "Member 'UFancyCarrySystemCarrier::CurrentFocusedCarryable' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarrier, OnCarryStarted) == 0x000208, "Member 'UFancyCarrySystemCarrier::OnCarryStarted' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarrier, OnCarryStopped) == 0x000218, "Member 'UFancyCarrySystemCarrier::OnCarryStopped' has a wrong offset!");

// Class Backrooms.CrosshairWidget
// 0x0000 (0x0260 - 0x0260)
class UCrosshairWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidget">();
	}
	static class UCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidget>();
	}
};
static_assert(alignof(UCrosshairWidget) == 0x000008, "Wrong alignment on UCrosshairWidget");
static_assert(sizeof(UCrosshairWidget) == 0x000260, "Wrong size on UCrosshairWidget");

// Class Backrooms.MotionScannerDirector
// 0x0088 (0x02A8 - 0x0220)
class AMotionScannerDirector : public AActor
{
public:
	float                                         CheckMotionRate;                                   // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoredActorsArr;                                  // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLIDARDotStruct>   NameToRTMap;                                       // 0x0238(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMotionScannerComponent*>        allMotionComponentsArr;                            // 0x0288(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           checkMotion_Handle;                                // 0x0298(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocalController;                                // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckLIDARDots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionScannerDirector">();
	}
	static class AMotionScannerDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMotionScannerDirector>();
	}
};
static_assert(alignof(AMotionScannerDirector) == 0x000008, "Wrong alignment on AMotionScannerDirector");
static_assert(sizeof(AMotionScannerDirector) == 0x0002A8, "Wrong size on AMotionScannerDirector");
static_assert(offsetof(AMotionScannerDirector, CheckMotionRate) == 0x000220, "Member 'AMotionScannerDirector::CheckMotionRate' has a wrong offset!");
static_assert(offsetof(AMotionScannerDirector, IgnoredActorsArr) == 0x000228, "Member 'AMotionScannerDirector::IgnoredActorsArr' has a wrong offset!");
static_assert(offsetof(AMotionScannerDirector, NameToRTMap) == 0x000238, "Member 'AMotionScannerDirector::NameToRTMap' has a wrong offset!");
static_assert(offsetof(AMotionScannerDirector, allMotionComponentsArr) == 0x000288, "Member 'AMotionScannerDirector::allMotionComponentsArr' has a wrong offset!");
static_assert(offsetof(AMotionScannerDirector, checkMotion_Handle) == 0x000298, "Member 'AMotionScannerDirector::checkMotion_Handle' has a wrong offset!");
static_assert(offsetof(AMotionScannerDirector, bIsLocalController) == 0x0002A0, "Member 'AMotionScannerDirector::bIsLocalController' has a wrong offset!");

// Class Backrooms.CustomUserWidget
// 0x0008 (0x0268 - 0x0260)
class UCustomUserWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           InventoryPanel;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool RefreshInventory();
	void SetHotbarSlot(int32 ItemSlot);
	void ToggleInventory(bool IsVisible_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomUserWidget">();
	}
	static class UCustomUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomUserWidget>();
	}
};
static_assert(alignof(UCustomUserWidget) == 0x000008, "Wrong alignment on UCustomUserWidget");
static_assert(sizeof(UCustomUserWidget) == 0x000268, "Wrong size on UCustomUserWidget");
static_assert(offsetof(UCustomUserWidget, InventoryPanel) == 0x000260, "Member 'UCustomUserWidget::InventoryPanel' has a wrong offset!");

// Class Backrooms.DroppedItem
// 0x0038 (0x0258 - 0x0220)
class ADroppedItem : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartWithPhysicsEnabled;                           // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanPickup;                                         // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0248(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           EvaluatePhysicsTimerHandle;                        // 0x0250(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EvaluatePhysics();
	void OnBeginFocus();
	void OnEndFocus();
	void StopPhysics();
	void UpdatePhysicsLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItem">();
	}
	static class ADroppedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItem>();
	}
};
static_assert(alignof(ADroppedItem) == 0x000008, "Wrong alignment on ADroppedItem");
static_assert(sizeof(ADroppedItem) == 0x000258, "Wrong size on ADroppedItem");
static_assert(offsetof(ADroppedItem, ItemMesh) == 0x000228, "Member 'ADroppedItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADroppedItem, ID) == 0x000230, "Member 'ADroppedItem::ID' has a wrong offset!");
static_assert(offsetof(ADroppedItem, StartWithPhysicsEnabled) == 0x000238, "Member 'ADroppedItem::StartWithPhysicsEnabled' has a wrong offset!");
static_assert(offsetof(ADroppedItem, CanPickup) == 0x000239, "Member 'ADroppedItem::CanPickup' has a wrong offset!");
static_assert(offsetof(ADroppedItem, SceneComponent) == 0x000240, "Member 'ADroppedItem::SceneComponent' has a wrong offset!");
static_assert(offsetof(ADroppedItem, TimerHandle) == 0x000248, "Member 'ADroppedItem::TimerHandle' has a wrong offset!");
static_assert(offsetof(ADroppedItem, EvaluatePhysicsTimerHandle) == 0x000250, "Member 'ADroppedItem::EvaluatePhysicsTimerHandle' has a wrong offset!");

// Class Backrooms.EnvQueryTest_CheckVisibility
// 0x0008 (0x0200 - 0x01F8)
class UEnvQueryTest_CheckVisibility final : public UEnvQueryTest
{
public:
	EEnvTestDot                                   TestMode;                                          // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CheckVisibility">();
	}
	static class UEnvQueryTest_CheckVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CheckVisibility>();
	}
};
static_assert(alignof(UEnvQueryTest_CheckVisibility) == 0x000008, "Wrong alignment on UEnvQueryTest_CheckVisibility");
static_assert(sizeof(UEnvQueryTest_CheckVisibility) == 0x000200, "Wrong size on UEnvQueryTest_CheckVisibility");
static_assert(offsetof(UEnvQueryTest_CheckVisibility, TestMode) == 0x0001F8, "Member 'UEnvQueryTest_CheckVisibility::TestMode' has a wrong offset!");

// Class Backrooms.FancyCameraComponent
// 0x0010 (0x07E0 - 0x07D0)
class UFancyCameraComponent final : public UCameraComponent
{
public:
	uint8                                         bLockRotToHmd : 1;                                 // 0x07D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLateUpdate : 1;                                // 0x07D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D1[0xF];                                      // 0x07D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyCameraComponent">();
	}
	static class UFancyCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyCameraComponent>();
	}
};
static_assert(alignof(UFancyCameraComponent) == 0x000010, "Wrong alignment on UFancyCameraComponent");
static_assert(sizeof(UFancyCameraComponent) == 0x0007E0, "Wrong size on UFancyCameraComponent");

// Class Backrooms.FancyCarrySystemCarryable
// 0x0040 (0x0240 - 0x0200)
class UFancyCarrySystemCarryable final : public USceneComponent
{
public:
	class UFancyCarrySystemCarrier*               CurrentCarrier;                                    // 0x01F8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeCarried;                                     // 0x0200(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             CarrySound;                                        // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DropSound;                                         // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnCarry;                                           // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDrop;                                            // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentCarrier();
	void SetCanBeCarried(bool CanBeCarried);

	bool CanBeCarried() const;
	bool IsBeingCarried() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyCarrySystemCarryable">();
	}
	static class UFancyCarrySystemCarryable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyCarrySystemCarryable>();
	}
};
static_assert(alignof(UFancyCarrySystemCarryable) == 0x000010, "Wrong alignment on UFancyCarrySystemCarryable");
static_assert(sizeof(UFancyCarrySystemCarryable) == 0x000240, "Wrong size on UFancyCarrySystemCarryable");
static_assert(offsetof(UFancyCarrySystemCarryable, CurrentCarrier) == 0x0001F8, "Member 'UFancyCarrySystemCarryable::CurrentCarrier' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarryable, bCanBeCarried) == 0x000200, "Member 'UFancyCarrySystemCarryable::bCanBeCarried' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarryable, CarrySound) == 0x000208, "Member 'UFancyCarrySystemCarryable::CarrySound' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarryable, DropSound) == 0x000210, "Member 'UFancyCarrySystemCarryable::DropSound' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarryable, OnCarry) == 0x000218, "Member 'UFancyCarrySystemCarryable::OnCarry' has a wrong offset!");
static_assert(offsetof(UFancyCarrySystemCarryable, OnDrop) == 0x000228, "Member 'UFancyCarrySystemCarryable::OnDrop' has a wrong offset!");

// Class Backrooms.FancyEntitySightingComponent
// 0x0010 (0x00C0 - 0x00B0)
class UFancyEntitySightingComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UFancyEntitySightingComponent* Entity)> OnEntitySighted;     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyEntitySightingComponent">();
	}
	static class UFancyEntitySightingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyEntitySightingComponent>();
	}
};
static_assert(alignof(UFancyEntitySightingComponent) == 0x000008, "Wrong alignment on UFancyEntitySightingComponent");
static_assert(sizeof(UFancyEntitySightingComponent) == 0x0000C0, "Wrong size on UFancyEntitySightingComponent");
static_assert(offsetof(UFancyEntitySightingComponent, OnEntitySighted) == 0x0000B0, "Member 'UFancyEntitySightingComponent::OnEntitySighted' has a wrong offset!");

// Class Backrooms.FancyEntitySightingManager
// 0x0060 (0x0110 - 0x00B0)
class UFancyEntitySightingManager final : public UActorComponent
{
public:
	TMap<class UFancyEntitySightingComponent*, bool> RegisteredEntities;                             // 0x00B0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnEntitySightedEvent;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnEntitySighting(class UFancyEntitySightingComponent* Entity);

	int32 GetNumEntitySightings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyEntitySightingManager">();
	}
	static class UFancyEntitySightingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyEntitySightingManager>();
	}
};
static_assert(alignof(UFancyEntitySightingManager) == 0x000008, "Wrong alignment on UFancyEntitySightingManager");
static_assert(sizeof(UFancyEntitySightingManager) == 0x000110, "Wrong size on UFancyEntitySightingManager");
static_assert(offsetof(UFancyEntitySightingManager, RegisteredEntities) == 0x0000B0, "Member 'UFancyEntitySightingManager::RegisteredEntities' has a wrong offset!");
static_assert(offsetof(UFancyEntitySightingManager, OnEntitySightedEvent) == 0x000100, "Member 'UFancyEntitySightingManager::OnEntitySightedEvent' has a wrong offset!");

// Class Backrooms.FancyFileSystemUtilsLibrary
// 0x0000 (0x0028 - 0x0028)
class UFancyFileSystemUtilsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USaveGame* LoadCurrentGameAsync(const class UObject* WorldContextObject, const class FString& SlotName, const int32 UserIndex);
	static void SaveGameToSlotAsync(const class UObject* WorldContextObject, class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex, const bool bForceSave);
	static bool WriteStringToSaveFile(const class FString& Filename, const class FString& Content, int32 UserIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyFileSystemUtilsLibrary">();
	}
	static class UFancyFileSystemUtilsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyFileSystemUtilsLibrary>();
	}
};
static_assert(alignof(UFancyFileSystemUtilsLibrary) == 0x000008, "Wrong alignment on UFancyFileSystemUtilsLibrary");
static_assert(sizeof(UFancyFileSystemUtilsLibrary) == 0x000028, "Wrong size on UFancyFileSystemUtilsLibrary");

// Class Backrooms.FancyGameInstance
// 0x0048 (0x0270 - 0x0228)
class UFancyGameInstance : public UAdvancedFriendsGameInstance
{
public:
	EEventType                                    CurrentEvent;                                      // 0x0228(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USteamManager*                          SteamManager;                                      // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSteamOverlayActive;                              // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentSlotName;                                   // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionData*                           MissionData;                                       // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EFancyInputDevice NewInputDevice)> OnInputDeviceChanged;           // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CheckCurrentEvent();
	struct FMissionStructure CompleteMission(float TimeCompleted);
	void CreateMission(const class FString& TargetEscapeLevel, float LevelBaseXP, float LevelTimeLimit, const class FString& MissionStructRowName);
	class FString GetCurrentGameLanguage();
	bool InitializeCPPElements();
	void InitializeStats();
	void OnInputDeviceChange(const EInputDevices NewInputDevice);
	void OnInputDeviceChangedEvent(const EFancyInputDevice NewInputDevice);
	void OnSteamOverlayIsActive(bool isOverlayActive);
	void ResetAchievements();
	void UpdateCurrentGameLanguage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyGameInstance">();
	}
	static class UFancyGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyGameInstance>();
	}
};
static_assert(alignof(UFancyGameInstance) == 0x000008, "Wrong alignment on UFancyGameInstance");
static_assert(sizeof(UFancyGameInstance) == 0x000270, "Wrong size on UFancyGameInstance");
static_assert(offsetof(UFancyGameInstance, CurrentEvent) == 0x000228, "Member 'UFancyGameInstance::CurrentEvent' has a wrong offset!");
static_assert(offsetof(UFancyGameInstance, SteamManager) == 0x000230, "Member 'UFancyGameInstance::SteamManager' has a wrong offset!");
static_assert(offsetof(UFancyGameInstance, IsSteamOverlayActive) == 0x000238, "Member 'UFancyGameInstance::IsSteamOverlayActive' has a wrong offset!");
static_assert(offsetof(UFancyGameInstance, CurrentSlotName) == 0x000240, "Member 'UFancyGameInstance::CurrentSlotName' has a wrong offset!");
static_assert(offsetof(UFancyGameInstance, MissionData) == 0x000250, "Member 'UFancyGameInstance::MissionData' has a wrong offset!");
static_assert(offsetof(UFancyGameInstance, OnInputDeviceChanged) == 0x000260, "Member 'UFancyGameInstance::OnInputDeviceChanged' has a wrong offset!");

// Class Backrooms.FancyGameMode
// 0x0018 (0x0320 - 0x0308)
class AFancyGameMode : public AGameMode
{
public:
	float                                         SanityDecrementAmount;                             // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLowerSanity;                                // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveGame*                              CachedSaveGame;                                    // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDecreaseSanity();
	void OnPreLoadMap(const class FString& MapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyGameMode">();
	}
	static class AFancyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFancyGameMode>();
	}
};
static_assert(alignof(AFancyGameMode) == 0x000008, "Wrong alignment on AFancyGameMode");
static_assert(sizeof(AFancyGameMode) == 0x000320, "Wrong size on AFancyGameMode");
static_assert(offsetof(AFancyGameMode, SanityDecrementAmount) == 0x000308, "Member 'AFancyGameMode::SanityDecrementAmount' has a wrong offset!");
static_assert(offsetof(AFancyGameMode, bShouldLowerSanity) == 0x00030C, "Member 'AFancyGameMode::bShouldLowerSanity' has a wrong offset!");
static_assert(offsetof(AFancyGameMode, CachedSaveGame) == 0x000310, "Member 'AFancyGameMode::CachedSaveGame' has a wrong offset!");

// Class Backrooms.FancyInputIconWidget
// 0x0008 (0x0268 - 0x0260)
class UFancyInputIconWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputDeviceChanged(EFancyInputDevice NewInputDevice);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyInputIconWidget">();
	}
	static class UFancyInputIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyInputIconWidget>();
	}
};
static_assert(alignof(UFancyInputIconWidget) == 0x000008, "Wrong alignment on UFancyInputIconWidget");
static_assert(sizeof(UFancyInputIconWidget) == 0x000268, "Wrong size on UFancyInputIconWidget");

// Class Backrooms.FancyMovementComponent
// 0x0010 (0x0B00 - 0x0AF0)
class UFancyMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_AF0[0x4];                                      // 0x0AF0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSprintSpeed;                                    // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x0AF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF9[0x7];                                      // 0x0AF9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSprinting(bool Sprint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyMovementComponent">();
	}
	static class UFancyMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyMovementComponent>();
	}
};
static_assert(alignof(UFancyMovementComponent) == 0x000010, "Wrong alignment on UFancyMovementComponent");
static_assert(sizeof(UFancyMovementComponent) == 0x000B00, "Wrong size on UFancyMovementComponent");
static_assert(offsetof(UFancyMovementComponent, MaxSprintSpeed) == 0x000AF4, "Member 'UFancyMovementComponent::MaxSprintSpeed' has a wrong offset!");
static_assert(offsetof(UFancyMovementComponent, bIsSprinting) == 0x000AF8, "Member 'UFancyMovementComponent::bIsSprinting' has a wrong offset!");

// Class Backrooms.FancyPlatformActivities
// 0x0000 (0x0028 - 0x0028)
class UFancyPlatformActivities final : public UBlueprintFunctionLibrary
{
public:
	static void EndActivity(const class FString& ActivityName, EActivityCompletionStatus Status);
	static int32 GetLastPlayedActivity();
	static bool IsActivityCallbackReceived();
	static void ResumeActivity(const class FString& ActivityName);
	static void SetActivityAvailability(const class FString& ActivityName, bool Enabled);
	static void SetLastPlayedActivity(int32 ActivityIndex);
	static void StartActivity(const class FString& ActivityName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyPlatformActivities">();
	}
	static class UFancyPlatformActivities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyPlatformActivities>();
	}
};
static_assert(alignof(UFancyPlatformActivities) == 0x000008, "Wrong alignment on UFancyPlatformActivities");
static_assert(sizeof(UFancyPlatformActivities) == 0x000028, "Wrong size on UFancyPlatformActivities");

// Class Backrooms.FancyPlatformUtilsLibrary
// 0x0000 (0x0028 - 0x0028)
class UFancyPlatformUtilsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EFancyInputDevice GetCurrentInputDevice();
	static class FString GetGameVersion();
	static bool IsCommunicationRestricted(const class APlayerController* PlayerController);
	static bool IsConnectedToNetwork();
	static bool IsConsoleBuild();
	static bool IsEditor();
	static bool IsOnAnySonyPlatform();
	static bool IsOnAnyXboxPlatform();
	static bool IsOnPS4Platform();
	static bool IsOnPS5Platform();
	static bool IsOnXboxOnePlatform();
	static bool IsOnXboxSeriesPlatform();
	static bool IsOnXboxSeriesSPlatform();
	static bool IsShippingBuild();
	static void SetUsingMultiplayerFeatures(const class APlayerController* PlayerController, bool bUsingMP);
	static bool SubscriptionCheck(const class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyPlatformUtilsLibrary">();
	}
	static class UFancyPlatformUtilsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyPlatformUtilsLibrary>();
	}
};
static_assert(alignof(UFancyPlatformUtilsLibrary) == 0x000008, "Wrong alignment on UFancyPlatformUtilsLibrary");
static_assert(sizeof(UFancyPlatformUtilsLibrary) == 0x000028, "Wrong size on UFancyPlatformUtilsLibrary");

// Class Backrooms.FancyPlayerController
// 0x0000 (0x0580 - 0x0580)
class AFancyPlayerController : public APlayerController
{
public:
	void ClientHUDInit();
	float GetObjectScreenRadius(class UStaticMeshComponent* MeshComponent);
	void OnPlayerTravel();
	void PrintLevelTimes();
	void PrintLevelTimesToLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyPlayerController">();
	}
	static class AFancyPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFancyPlayerController>();
	}
};
static_assert(alignof(AFancyPlayerController) == 0x000008, "Wrong alignment on AFancyPlayerController");
static_assert(sizeof(AFancyPlayerController) == 0x000580, "Wrong size on AFancyPlayerController");

// Class Backrooms.FancyPlayerState
// 0x0018 (0x0338 - 0x0320)
class AFancyPlayerState : public APlayerState
{
public:
	class UInventoryComponent*                    InventoryComponent;                                // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sanity;                                            // 0x0328(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSanity;                                         // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldLowerSanity;                                 // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSanity(float Amount);
	void OnKillPlayer();
	void OnRep_Sanity();
	void RemoveSanity(float Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyPlayerState">();
	}
	static class AFancyPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFancyPlayerState>();
	}
};
static_assert(alignof(AFancyPlayerState) == 0x000008, "Wrong alignment on AFancyPlayerState");
static_assert(sizeof(AFancyPlayerState) == 0x000338, "Wrong size on AFancyPlayerState");
static_assert(offsetof(AFancyPlayerState, InventoryComponent) == 0x000320, "Member 'AFancyPlayerState::InventoryComponent' has a wrong offset!");
static_assert(offsetof(AFancyPlayerState, Sanity) == 0x000328, "Member 'AFancyPlayerState::Sanity' has a wrong offset!");
static_assert(offsetof(AFancyPlayerState, MaxSanity) == 0x00032C, "Member 'AFancyPlayerState::MaxSanity' has a wrong offset!");
static_assert(offsetof(AFancyPlayerState, ShouldLowerSanity) == 0x000330, "Member 'AFancyPlayerState::ShouldLowerSanity' has a wrong offset!");

// Class Backrooms.FancySpringArmComponent
// 0x0030 (0x02B0 - 0x0280)
class UFancySpringArmComponent final : public USpringArmComponent
{
public:
	float                                         WalkCameraLagSpeed;                                // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkCameraLagMaxDistance;                          // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCameraLagSpeed;                              // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCameraLagMaxDistance;                        // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverCameraLagSpeed;                             // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInterpolation;                              // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x1B];                                     // 0x0295(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancySpringArmComponent">();
	}
	static class UFancySpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancySpringArmComponent>();
	}
};
static_assert(alignof(UFancySpringArmComponent) == 0x000010, "Wrong alignment on UFancySpringArmComponent");
static_assert(sizeof(UFancySpringArmComponent) == 0x0002B0, "Wrong size on UFancySpringArmComponent");
static_assert(offsetof(UFancySpringArmComponent, WalkCameraLagSpeed) == 0x000280, "Member 'UFancySpringArmComponent::WalkCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UFancySpringArmComponent, WalkCameraLagMaxDistance) == 0x000284, "Member 'UFancySpringArmComponent::WalkCameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UFancySpringArmComponent, SprintCameraLagSpeed) == 0x000288, "Member 'UFancySpringArmComponent::SprintCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UFancySpringArmComponent, SprintCameraLagMaxDistance) == 0x00028C, "Member 'UFancySpringArmComponent::SprintCameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UFancySpringArmComponent, RecoverCameraLagSpeed) == 0x000290, "Member 'UFancySpringArmComponent::RecoverCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UFancySpringArmComponent, bIgnoreInterpolation) == 0x000294, "Member 'UFancySpringArmComponent::bIgnoreInterpolation' has a wrong offset!");

// Class Backrooms.FancyUserControllerSystem
// 0x0128 (0x0158 - 0x0030)
class UFancyUserControllerSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsSameUser)> OnActiveUserChanged;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAccountPickerClosed;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ControllerId, bool PrevStatus, bool NewStatus)> OnLoginStatusChangedDelegate; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHideUserReestablishMessage;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EEstablishUserReason reason)> OnShowUserReestablishMessage;        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSlateBrush& Icon)> OnUserIconUpdated;                // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUserReestablishMessageClosed;                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EOnlineStatus OldConnectionStatus, EOnlineStatus NewConnectionStatus)> OnConnectionStatusChanged; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnApplicationReactivate;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnApplicationDeactivate;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsPaused)> OnApplicationPause;                               // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugLogging;                               // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x67];                                      // 0x00F1(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EstablishInitialUser();
	struct FSlateBrush GetActiveUserIcon();
	class FString GetDisplayName();
	bool OpenAccountPickerFromBP();
	void SetUnpauseBlocked(bool bNewIsUnpauseBlocked);

	EOnlineStatus GetCurrentConnectionStatus() const;
	bool HasEstablishedInitialUser() const;
	bool HasValidUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyUserControllerSystem">();
	}
	static class UFancyUserControllerSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyUserControllerSystem>();
	}
};
static_assert(alignof(UFancyUserControllerSystem) == 0x000008, "Wrong alignment on UFancyUserControllerSystem");
static_assert(sizeof(UFancyUserControllerSystem) == 0x000158, "Wrong size on UFancyUserControllerSystem");
static_assert(offsetof(UFancyUserControllerSystem, OnActiveUserChanged) == 0x000040, "Member 'UFancyUserControllerSystem::OnActiveUserChanged' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnAccountPickerClosed) == 0x000050, "Member 'UFancyUserControllerSystem::OnAccountPickerClosed' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnLoginStatusChangedDelegate) == 0x000060, "Member 'UFancyUserControllerSystem::OnLoginStatusChangedDelegate' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnHideUserReestablishMessage) == 0x000070, "Member 'UFancyUserControllerSystem::OnHideUserReestablishMessage' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnShowUserReestablishMessage) == 0x000080, "Member 'UFancyUserControllerSystem::OnShowUserReestablishMessage' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnUserIconUpdated) == 0x000090, "Member 'UFancyUserControllerSystem::OnUserIconUpdated' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnUserReestablishMessageClosed) == 0x0000A0, "Member 'UFancyUserControllerSystem::OnUserReestablishMessageClosed' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnConnectionStatusChanged) == 0x0000B0, "Member 'UFancyUserControllerSystem::OnConnectionStatusChanged' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnApplicationReactivate) == 0x0000C0, "Member 'UFancyUserControllerSystem::OnApplicationReactivate' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnApplicationDeactivate) == 0x0000D0, "Member 'UFancyUserControllerSystem::OnApplicationDeactivate' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, OnApplicationPause) == 0x0000E0, "Member 'UFancyUserControllerSystem::OnApplicationPause' has a wrong offset!");
static_assert(offsetof(UFancyUserControllerSystem, bEnableDebugLogging) == 0x0000F0, "Member 'UFancyUserControllerSystem::bEnableDebugLogging' has a wrong offset!");

// Class Backrooms.FancyVideoPlayer
// 0x00A0 (0x02C0 - 0x0220)
class alignas(0x10) AFancyVideoPlayer final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFancyVotingComponent*                  VotingComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoStartedDelegate;                            // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoEndedDelegate;                              // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoSuspendedDelegate;                          // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoSkippedDelegate;                            // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBinkMediaPlayer*                       MediaPlayer;                                       // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaPlayer*                       MediaPlayerReference;                              // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                VideoWidget;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            VideoWidgetReference;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentVideo;                                      // 0x0290(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanSkip;                                          // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0xF];                                      // 0x02B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMediaClosed();
	void OnMediaReachedEnd();
	void OnPlaybackSuspended();
	void OnSkipVoteFinished(bool Result);
	void OnVideoEnded();
	void OnVideoStarted();
	void PauseVideoClients();
	void PauseVideoServer();
	void PlayVideoClients(const class FString& MediaFileName, bool AddToQueue);
	void PlayVideoServer(const class FString& MediaFileName, bool AddToQueue);
	void SetCanSkip(bool CanSkip);
	void SkipVideoClients();
	void SkipVideoServer();
	void StopVideoClients();
	void StopVideoServer();

	bool CanSkip() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyVideoPlayer">();
	}
	static class AFancyVideoPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFancyVideoPlayer>();
	}
};
static_assert(alignof(AFancyVideoPlayer) == 0x000010, "Wrong alignment on AFancyVideoPlayer");
static_assert(sizeof(AFancyVideoPlayer) == 0x0002C0, "Wrong size on AFancyVideoPlayer");
static_assert(offsetof(AFancyVideoPlayer, SceneComponent) == 0x000220, "Member 'AFancyVideoPlayer::SceneComponent' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, VotingComponent) == 0x000228, "Member 'AFancyVideoPlayer::VotingComponent' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, OnVideoStartedDelegate) == 0x000230, "Member 'AFancyVideoPlayer::OnVideoStartedDelegate' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, OnVideoEndedDelegate) == 0x000240, "Member 'AFancyVideoPlayer::OnVideoEndedDelegate' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, OnVideoSuspendedDelegate) == 0x000250, "Member 'AFancyVideoPlayer::OnVideoSuspendedDelegate' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, OnVideoSkippedDelegate) == 0x000260, "Member 'AFancyVideoPlayer::OnVideoSkippedDelegate' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, MediaPlayer) == 0x000270, "Member 'AFancyVideoPlayer::MediaPlayer' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, MediaPlayerReference) == 0x000278, "Member 'AFancyVideoPlayer::MediaPlayerReference' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, VideoWidget) == 0x000280, "Member 'AFancyVideoPlayer::VideoWidget' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, VideoWidgetReference) == 0x000288, "Member 'AFancyVideoPlayer::VideoWidgetReference' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, CurrentVideo) == 0x000290, "Member 'AFancyVideoPlayer::CurrentVideo' has a wrong offset!");
static_assert(offsetof(AFancyVideoPlayer, bCanSkip) == 0x0002B0, "Member 'AFancyVideoPlayer::bCanSkip' has a wrong offset!");

// Class Backrooms.FancyVideoSubsystem
// 0x0008 (0x0038 - 0x0030)
class UFancyVideoSubsystem final : public UGameInstanceSubsystem
{
public:
	class AFancyVideoPlayer*                      ActiveVideoPlayer;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PauseVideo();
	void PlayVideo(const class FString& MediaFileName, bool AddToQueue);
	void SkipVideo();
	void StopVideo();

	class AFancyVideoPlayer* GetActiveVideoPlayer() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyVideoSubsystem">();
	}
	static class UFancyVideoSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyVideoSubsystem>();
	}
};
static_assert(alignof(UFancyVideoSubsystem) == 0x000008, "Wrong alignment on UFancyVideoSubsystem");
static_assert(sizeof(UFancyVideoSubsystem) == 0x000038, "Wrong size on UFancyVideoSubsystem");
static_assert(offsetof(UFancyVideoSubsystem, ActiveVideoPlayer) == 0x000030, "Member 'UFancyVideoSubsystem::ActiveVideoPlayer' has a wrong offset!");

// Class Backrooms.FancyVotingComponent
// 0x00A8 (0x0158 - 0x00B0)
class UFancyVotingComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnVoteStarted;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Result)>   OnVoteFinished;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVoteCanceled;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVoteData& VoteData)> OnVoteChanged;                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVoteData                              ActiveVote;                                        // 0x00F0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)

public:
	void ChangeVoteServer(class APlayerState* PlayerState, bool NewVote);
	bool CheckVoteFinishedCondition();
	void FinishVoteMulticast(bool Result);
	void FinishVoteServer();
	void StartVoteMulticast(const struct FVoteParameters& VoteParameters);
	void StartVoteServer(const struct FVoteParameters& VoteParameters);
	void VoteUpdated(class APlayerState* PlayerState, bool NewVote);

	bool IsVotingActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FancyVotingComponent">();
	}
	static class UFancyVotingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFancyVotingComponent>();
	}
};
static_assert(alignof(UFancyVotingComponent) == 0x000008, "Wrong alignment on UFancyVotingComponent");
static_assert(sizeof(UFancyVotingComponent) == 0x000158, "Wrong size on UFancyVotingComponent");
static_assert(offsetof(UFancyVotingComponent, OnVoteStarted) == 0x0000B0, "Member 'UFancyVotingComponent::OnVoteStarted' has a wrong offset!");
static_assert(offsetof(UFancyVotingComponent, OnVoteFinished) == 0x0000C0, "Member 'UFancyVotingComponent::OnVoteFinished' has a wrong offset!");
static_assert(offsetof(UFancyVotingComponent, OnVoteCanceled) == 0x0000D0, "Member 'UFancyVotingComponent::OnVoteCanceled' has a wrong offset!");
static_assert(offsetof(UFancyVotingComponent, OnVoteChanged) == 0x0000E0, "Member 'UFancyVotingComponent::OnVoteChanged' has a wrong offset!");
static_assert(offsetof(UFancyVotingComponent, ActiveVote) == 0x0000F0, "Member 'UFancyVotingComponent::ActiveVote' has a wrong offset!");

// Class Backrooms.GripMotionControllerComponent
// 0x02F0 (0x0800 - 0x0510)
class UGripMotionControllerComponent final : public UMotionControllerComponent
{
public:
	bool                                          bScaleTracking;                                    // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrackingScaler;                                    // 0x050C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitMinHeight;                                   // 0x0518(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumHeight;                                     // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitMaxHeight;                                   // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumHeight;                                     // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetByHMD;                                      // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeashToHMD;                                       // 0x0529(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52A[0x2];                                      // 0x052A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeashRange;                                        // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x40];                                     // 0x0530(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSmoothHandTracking;                               // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x1];                                      // 0x0571(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSmoothWithEuroLowPassFunction;                    // 0x0572(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_573[0x1];                                      // 0x0573(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingSpeed;                                    // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBPEuroLowPassFilterTrans              EuroSmoothingParams;                               // 0x0580(0x0150)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D0[0x30];                                     // 0x06D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EVRVelocityType                               VelocityCalculationType;                           // 0x0700(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSampleVelocityInWorldSpace;                       // 0x0701(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_702[0x2];                                      // 0x0702(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VelocitySamples;                                   // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_708[0x20];                                     // 0x0708(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOffsetByControllerProfile;                        // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x37];                                     // 0x0729(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReplicatedControllerTransform;                     // 0x0760(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LastUpdatesTransform;                              // 0x0790(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x1C];                                     // 0x07C0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControllerNetUpdateRate;                           // 0x07DC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x4];                                      // 0x07E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSmoothReplicatedMotion;                           // 0x07E4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateWithoutTracking;                         // 0x07E5(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E6[0x1A];                                     // 0x07E6(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BP_IsLocallyControlled();
	void GetPhysicsVelocity(struct FVector* AngularVelocity, struct FVector* LinearVelocity);
	void OnRep_ReplicatedControllerTransform();
	void Server_SendControllerTransform(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GripMotionControllerComponent">();
	}
	static class UGripMotionControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGripMotionControllerComponent>();
	}
};
static_assert(alignof(UGripMotionControllerComponent) == 0x000010, "Wrong alignment on UGripMotionControllerComponent");
static_assert(sizeof(UGripMotionControllerComponent) == 0x000800, "Wrong size on UGripMotionControllerComponent");
static_assert(offsetof(UGripMotionControllerComponent, bScaleTracking) == 0x000508, "Member 'UGripMotionControllerComponent::bScaleTracking' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, TrackingScaler) == 0x00050C, "Member 'UGripMotionControllerComponent::TrackingScaler' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bLimitMinHeight) == 0x000518, "Member 'UGripMotionControllerComponent::bLimitMinHeight' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, MinimumHeight) == 0x00051C, "Member 'UGripMotionControllerComponent::MinimumHeight' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bLimitMaxHeight) == 0x000520, "Member 'UGripMotionControllerComponent::bLimitMaxHeight' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, MaximumHeight) == 0x000524, "Member 'UGripMotionControllerComponent::MaximumHeight' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bOffsetByHMD) == 0x000528, "Member 'UGripMotionControllerComponent::bOffsetByHMD' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bLeashToHMD) == 0x000529, "Member 'UGripMotionControllerComponent::bLeashToHMD' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, LeashRange) == 0x00052C, "Member 'UGripMotionControllerComponent::LeashRange' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bSmoothHandTracking) == 0x000570, "Member 'UGripMotionControllerComponent::bSmoothHandTracking' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bSmoothWithEuroLowPassFunction) == 0x000572, "Member 'UGripMotionControllerComponent::bSmoothWithEuroLowPassFunction' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, SmoothingSpeed) == 0x000574, "Member 'UGripMotionControllerComponent::SmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, EuroSmoothingParams) == 0x000580, "Member 'UGripMotionControllerComponent::EuroSmoothingParams' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, VelocityCalculationType) == 0x000700, "Member 'UGripMotionControllerComponent::VelocityCalculationType' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bSampleVelocityInWorldSpace) == 0x000701, "Member 'UGripMotionControllerComponent::bSampleVelocityInWorldSpace' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, VelocitySamples) == 0x000704, "Member 'UGripMotionControllerComponent::VelocitySamples' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bOffsetByControllerProfile) == 0x000728, "Member 'UGripMotionControllerComponent::bOffsetByControllerProfile' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, ReplicatedControllerTransform) == 0x000760, "Member 'UGripMotionControllerComponent::ReplicatedControllerTransform' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, LastUpdatesTransform) == 0x000790, "Member 'UGripMotionControllerComponent::LastUpdatesTransform' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, ControllerNetUpdateRate) == 0x0007DC, "Member 'UGripMotionControllerComponent::ControllerNetUpdateRate' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bSmoothReplicatedMotion) == 0x0007E4, "Member 'UGripMotionControllerComponent::bSmoothReplicatedMotion' has a wrong offset!");
static_assert(offsetof(UGripMotionControllerComponent, bReplicateWithoutTracking) == 0x0007E5, "Member 'UGripMotionControllerComponent::bReplicateWithoutTracking' has a wrong offset!");

// Class Backrooms.InspectableActor
// 0x0078 (0x0298 - 0x0220)
class AInspectableActor final : public AActor
{
public:
	class FText                                   Name_0;                                            // 0x0220(0x0018)(NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0240(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             PlayerReference;                                   // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistance;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0xC];                                      // 0x0254(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           BlurTimerHandle;                                   // 0x0260(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        FocusTarget;                                       // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Mesh2;                                             // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       InspectionCamera;                                  // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UStaticMeshComponent* GetMesh();
	void SetCameraLocation(class UCameraComponent* CameraComponent);
	void SetPlayerRef(class ACharacter* Ref);
	void SetViewing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectableActor">();
	}
	static class AInspectableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInspectableActor>();
	}
};
static_assert(alignof(AInspectableActor) == 0x000008, "Wrong alignment on AInspectableActor");
static_assert(sizeof(AInspectableActor) == 0x000298, "Wrong size on AInspectableActor");
static_assert(offsetof(AInspectableActor, Name_0) == 0x000220, "Member 'AInspectableActor::Name_0' has a wrong offset!");
static_assert(offsetof(AInspectableActor, Description) == 0x000238, "Member 'AInspectableActor::Description' has a wrong offset!");
static_assert(offsetof(AInspectableActor, Quantity) == 0x000240, "Member 'AInspectableActor::Quantity' has a wrong offset!");
static_assert(offsetof(AInspectableActor, PlayerReference) == 0x000248, "Member 'AInspectableActor::PlayerReference' has a wrong offset!");
static_assert(offsetof(AInspectableActor, CameraDistance) == 0x000250, "Member 'AInspectableActor::CameraDistance' has a wrong offset!");
static_assert(offsetof(AInspectableActor, BlurTimerHandle) == 0x000260, "Member 'AInspectableActor::BlurTimerHandle' has a wrong offset!");
static_assert(offsetof(AInspectableActor, SceneComponent) == 0x000278, "Member 'AInspectableActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AInspectableActor, FocusTarget) == 0x000280, "Member 'AInspectableActor::FocusTarget' has a wrong offset!");
static_assert(offsetof(AInspectableActor, Mesh2) == 0x000288, "Member 'AInspectableActor::Mesh2' has a wrong offset!");
static_assert(offsetof(AInspectableActor, InspectionCamera) == 0x000290, "Member 'AInspectableActor::InspectionCamera' has a wrong offset!");

// Class Backrooms.InteractableCameraComponent
// 0x0000 (0x07D0 - 0x07D0)
class UInteractableCameraComponent final : public UCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableCameraComponent">();
	}
	static class UInteractableCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableCameraComponent>();
	}
};
static_assert(alignof(UInteractableCameraComponent) == 0x000010, "Wrong alignment on UInteractableCameraComponent");
static_assert(sizeof(UInteractableCameraComponent) == 0x0007D0, "Wrong size on UInteractableCameraComponent");

// Class Backrooms.InteractableComponent
// 0x0010 (0x04F0 - 0x04E0)
class UInteractableComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsUsable;                                          // 0x04E8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WasUsed;                                           // 0x04E9(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EA[0x6];                                      // 0x04EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockUsage();
	void OnRep_WasUsed();
	void OnUsedAll();
	void OnUsedMulticast();
	void OnUsedNotify();
	void OnUsedServer(class ACharacter* Character);
	void ResetUsage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000010, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x0004F0, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, IsUsable) == 0x0004E8, "Member 'UInteractableComponent::IsUsable' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, WasUsed) == 0x0004E9, "Member 'UInteractableComponent::WasUsed' has a wrong offset!");

// Class Backrooms.InteractableInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractableInterface final
{
public:
	void OnActorUsed(class ACharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableInterface">();
	}
	static class IInteractableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractableInterface) == 0x000001, "Wrong alignment on IInteractableInterface");
static_assert(sizeof(IInteractableInterface) == 0x000001, "Wrong size on IInteractableInterface");

// Class Backrooms.InventoryComponent
// 0x0020 (0x00D0 - 0x00B0)
class UInventoryComponent final : public UActorComponent
{
public:
	int32                                         InventorySize;                                     // 0x00B0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventoryItem*>                 Inventory2;                                        // 0x00B8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class AItemActor*                             EquippedItem;                                      // 0x00C8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool AddToInventory(class UInventoryItem* Item);
	void DropItem(uint8 Slot);
	class UInventoryItem* GetItemAtSlot(int32 SlotIndex);
	bool IsSlotEmpty(int32 SlotIndex);
	void RemoveFromInventory(class UInventoryItem* Item);
	void SwapInventoryItems(int32 FirstIdx, int32 SecondIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x0000D0, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, InventorySize) == 0x0000B0, "Member 'UInventoryComponent::InventorySize' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, Inventory2) == 0x0000B8, "Member 'UInventoryComponent::Inventory2' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, EquippedItem) == 0x0000C8, "Member 'UInventoryComponent::EquippedItem' has a wrong offset!");

// Class Backrooms.InventoryItem
// 0x0070 (0x0098 - 0x0028)
class UInventoryItem final : public UObject
{
public:
	struct FItemStructure                         Structure;                                         // 0x0028(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItem">();
	}
	static class UInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryItem>();
	}
};
static_assert(alignof(UInventoryItem) == 0x000008, "Wrong alignment on UInventoryItem");
static_assert(sizeof(UInventoryItem) == 0x000098, "Wrong size on UInventoryItem");
static_assert(offsetof(UInventoryItem, Structure) == 0x000028, "Member 'UInventoryItem::Structure' has a wrong offset!");
static_assert(offsetof(UInventoryItem, Quantity) == 0x000090, "Member 'UInventoryItem::Quantity' has a wrong offset!");

// Class Backrooms.ItemActor
// 0x00A0 (0x02C0 - 0x0220)
class AItemActor final : public AActor
{
public:
	struct FItemStructure                         Structure;                                         // 0x0220(0x0068)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseable;                                         // 0x028C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayUseAnimation;                                 // 0x028D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E[0x2];                                      // 0x028E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh2;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        IdleAnimation;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        UseAnimation;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        EquipMontage;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        UnEquipMontage;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CustomInventoryUse();
	void Use();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemActor">();
	}
	static class AItemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemActor>();
	}
};
static_assert(alignof(AItemActor) == 0x000008, "Wrong alignment on AItemActor");
static_assert(sizeof(AItemActor) == 0x0002C0, "Wrong size on AItemActor");
static_assert(offsetof(AItemActor, Structure) == 0x000220, "Member 'AItemActor::Structure' has a wrong offset!");
static_assert(offsetof(AItemActor, Quantity) == 0x000288, "Member 'AItemActor::Quantity' has a wrong offset!");
static_assert(offsetof(AItemActor, IsUseable) == 0x00028C, "Member 'AItemActor::IsUseable' has a wrong offset!");
static_assert(offsetof(AItemActor, bPlayUseAnimation) == 0x00028D, "Member 'AItemActor::bPlayUseAnimation' has a wrong offset!");
static_assert(offsetof(AItemActor, SceneComponent) == 0x000290, "Member 'AItemActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AItemActor, Mesh2) == 0x000298, "Member 'AItemActor::Mesh2' has a wrong offset!");
static_assert(offsetof(AItemActor, IdleAnimation) == 0x0002A0, "Member 'AItemActor::IdleAnimation' has a wrong offset!");
static_assert(offsetof(AItemActor, UseAnimation) == 0x0002A8, "Member 'AItemActor::UseAnimation' has a wrong offset!");
static_assert(offsetof(AItemActor, EquipMontage) == 0x0002B0, "Member 'AItemActor::EquipMontage' has a wrong offset!");
static_assert(offsetof(AItemActor, UnEquipMontage) == 0x0002B8, "Member 'AItemActor::UnEquipMontage' has a wrong offset!");

// Class Backrooms.Level0Generator
// 0x0018 (0x0238 - 0x0220)
class ALevel0Generator final : public AActor
{
public:
	class UStaticMesh*                            FloorMesh;                                         // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WallMesh;                                          // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CeilingMesh;                                       // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Generate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Level0Generator">();
	}
	static class ALevel0Generator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevel0Generator>();
	}
};
static_assert(alignof(ALevel0Generator) == 0x000008, "Wrong alignment on ALevel0Generator");
static_assert(sizeof(ALevel0Generator) == 0x000238, "Wrong size on ALevel0Generator");
static_assert(offsetof(ALevel0Generator, FloorMesh) == 0x000220, "Member 'ALevel0Generator::FloorMesh' has a wrong offset!");
static_assert(offsetof(ALevel0Generator, WallMesh) == 0x000228, "Member 'ALevel0Generator::WallMesh' has a wrong offset!");
static_assert(offsetof(ALevel0Generator, CeilingMesh) == 0x000230, "Member 'ALevel0Generator::CeilingMesh' has a wrong offset!");

// Class Backrooms.LIDARBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULIDARBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLIDARDotStruct CreateLiDarDot(class UObject* caller, class UTextureRenderTarget2D* RenderTarget);
	static bool FindCollisionUVSkeletalMesh(const struct FHitResult& Hit, struct FVector2D* UV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LIDARBlueprintFunctionLibrary">();
	}
	static class ULIDARBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULIDARBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(ULIDARBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on ULIDARBlueprintFunctionLibrary");
static_assert(sizeof(ULIDARBlueprintFunctionLibrary) == 0x000028, "Wrong size on ULIDARBlueprintFunctionLibrary");

// Class Backrooms.LIDARComponent
// 0x00E0 (0x0190 - 0x00B0)
class ULIDARComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              BP_ScannerTrace;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              BP_UpdateColors;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x14];                                      // 0x00D0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInScannerMode;                                    // 0x00E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MuzzleSocketName;                                  // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FColor>            AbbrevToColorMap;                                  // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ScannerSpread;                                     // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x8];                                      // 0x0144(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScannerRange;                                      // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateOfScannerFire;                                 // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BeamColorAbbrv;                                    // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BeamColor;                                         // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 KillModeColor;                                     // 0x0174(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeamWidth;                                         // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x8];                                      // 0x017C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeamGlowAmount;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotGlowAmount;                                     // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotScaleFactor;                                    // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ShootAuto();
	void ShootGun();
	void ShootReset();

	struct FHitResult ScannerTrace(class UStaticMeshComponent* Mesh) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LIDARComponent">();
	}
	static class ULIDARComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULIDARComponent>();
	}
};
static_assert(alignof(ULIDARComponent) == 0x000008, "Wrong alignment on ULIDARComponent");
static_assert(sizeof(ULIDARComponent) == 0x000190, "Wrong size on ULIDARComponent");
static_assert(offsetof(ULIDARComponent, BP_ScannerTrace) == 0x0000B0, "Member 'ULIDARComponent::BP_ScannerTrace' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, BP_UpdateColors) == 0x0000C0, "Member 'ULIDARComponent::BP_UpdateColors' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, bInScannerMode) == 0x0000E4, "Member 'ULIDARComponent::bInScannerMode' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, MuzzleSocketName) == 0x0000E8, "Member 'ULIDARComponent::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, AbbrevToColorMap) == 0x0000F0, "Member 'ULIDARComponent::AbbrevToColorMap' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, ScannerSpread) == 0x000140, "Member 'ULIDARComponent::ScannerSpread' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, ScannerRange) == 0x00014C, "Member 'ULIDARComponent::ScannerRange' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, RateOfScannerFire) == 0x000150, "Member 'ULIDARComponent::RateOfScannerFire' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, BeamColorAbbrv) == 0x000160, "Member 'ULIDARComponent::BeamColorAbbrv' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, BeamColor) == 0x000170, "Member 'ULIDARComponent::BeamColor' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, KillModeColor) == 0x000174, "Member 'ULIDARComponent::KillModeColor' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, BeamWidth) == 0x000178, "Member 'ULIDARComponent::BeamWidth' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, BeamGlowAmount) == 0x000184, "Member 'ULIDARComponent::BeamGlowAmount' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, DotGlowAmount) == 0x000188, "Member 'ULIDARComponent::DotGlowAmount' has a wrong offset!");
static_assert(offsetof(ULIDARComponent, DotScaleFactor) == 0x00018C, "Member 'ULIDARComponent::DotScaleFactor' has a wrong offset!");

// Class Backrooms.MapEditorCharacterMovement
// 0x0020 (0x0B10 - 0x0AF0)
class UMapEditorCharacterMovement final : public UCharacterMovementComponent
{
public:
	bool                                          bCenterMouseOnStopMovementMode;                    // 0x0AF0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF1[0x13];                                     // 0x0AF1(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedMultiplier;                                // 0x0B04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeedMultiplier;                                // 0x0B08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0C[0x4];                                      // 0x0B0C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseSpeedMultiplier(float DecreaseAmount);
	void EnterMovementMode(bool Enter);
	void IncreaseSpeedMultiplier(float IncreaseAmount);
	void Init();
	void LookUp(float Value);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void MoveUp(float Value);
	void Server_SetSpeedMultiplier(float SpeedMultiplier);
	void Turn(float Value);

	bool InMovementMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorCharacterMovement">();
	}
	static class UMapEditorCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEditorCharacterMovement>();
	}
};
static_assert(alignof(UMapEditorCharacterMovement) == 0x000010, "Wrong alignment on UMapEditorCharacterMovement");
static_assert(sizeof(UMapEditorCharacterMovement) == 0x000B10, "Wrong size on UMapEditorCharacterMovement");
static_assert(offsetof(UMapEditorCharacterMovement, bCenterMouseOnStopMovementMode) == 0x000AF0, "Member 'UMapEditorCharacterMovement::bCenterMouseOnStopMovementMode' has a wrong offset!");
static_assert(offsetof(UMapEditorCharacterMovement, MaxSpeedMultiplier) == 0x000B04, "Member 'UMapEditorCharacterMovement::MaxSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UMapEditorCharacterMovement, MinSpeedMultiplier) == 0x000B08, "Member 'UMapEditorCharacterMovement::MinSpeedMultiplier' has a wrong offset!");

// Class Backrooms.MapEditorGizmo
// 0x00A0 (0x02C0 - 0x0220)
class AMapEditorGizmo final : public AActor
{
public:
	class UStaticMeshComponent*                   Origin;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ZAxis;                                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   XAxis;                                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   YAxis;                                             // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Yaw;                                               // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Roll;                                              // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Pitch;                                             // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ScaleZ;                                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ScaleX;                                            // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ScaleY;                                            // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSlowdown;                                  // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4C];                                     // 0x0274(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorGizmo">();
	}
	static class AMapEditorGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapEditorGizmo>();
	}
};
static_assert(alignof(AMapEditorGizmo) == 0x000008, "Wrong alignment on AMapEditorGizmo");
static_assert(sizeof(AMapEditorGizmo) == 0x0002C0, "Wrong size on AMapEditorGizmo");
static_assert(offsetof(AMapEditorGizmo, Origin) == 0x000220, "Member 'AMapEditorGizmo::Origin' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, ZAxis) == 0x000228, "Member 'AMapEditorGizmo::ZAxis' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, XAxis) == 0x000230, "Member 'AMapEditorGizmo::XAxis' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, YAxis) == 0x000238, "Member 'AMapEditorGizmo::YAxis' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, Yaw) == 0x000240, "Member 'AMapEditorGizmo::Yaw' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, Roll) == 0x000248, "Member 'AMapEditorGizmo::Roll' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, Pitch) == 0x000250, "Member 'AMapEditorGizmo::Pitch' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, ScaleZ) == 0x000258, "Member 'AMapEditorGizmo::ScaleZ' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, ScaleX) == 0x000260, "Member 'AMapEditorGizmo::ScaleX' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, ScaleY) == 0x000268, "Member 'AMapEditorGizmo::ScaleY' has a wrong offset!");
static_assert(offsetof(AMapEditorGizmo, MovementSlowdown) == 0x000270, "Member 'AMapEditorGizmo::MovementSlowdown' has a wrong offset!");

// Class Backrooms.MapEditorHandlerComponent
// 0x0090 (0x0140 - 0x00B0)
class alignas(0x10) UMapEditorHandlerComponent final : public UActorComponent
{
public:
	ECollisionChannel                             TraceCollisionChannel;                             // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapDirectory;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMapEditorGizmo>            GizmoClass;                                        // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicationRate;                                   // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentActor;                                      // 0x00D8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x38];                                      // 0x00E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapEditorSnapping                     SnapAmount;                                        // 0x0118(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x1C];                                     // 0x0124(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteActor();
	void DeselectActor();
	void Grab();
	void Init();
	struct FHitResult MouseTrace(float Distance, bool* bHitGizmo, bool bDrawDebugLine);
	void OnRep_CurrentActor();
	void Release();
	void Server_DeleteActor(class AActor* Actor);
	void Server_ReplicateTransform(class AActor* Actor, const struct FTransform& Transform);
	void Server_SpawnActor(TSubclassOf<class AActor> ActorClass);
	void Server_UnpossessToReturnPawn();
	void SetActor(class AActor* Actor);
	void SetActorTransform(const struct FTransform& NewTransform);
	void SetReturnPawn(class APawn* Pawn);
	void SetSnapAmount(const struct FMapEditorSnapping& SnappingAmounts);
	void ShowMovement();
	void ShowRotation();
	void ShowScale();
	void SpawnActor(TSubclassOf<class AActor> ActorClass);
	void Undo();
	void UnpossessToReturnPawn();

	class FString GetActorName() const;
	struct FTransform GetActorTransform() const;
	EGizmoType GetGizmoType() const;
	float GetReplicationRate() const;
	struct FMapEditorSnapping GetSnapAmount() const;
	bool HasValidReturnPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorHandlerComponent">();
	}
	static class UMapEditorHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEditorHandlerComponent>();
	}
};
static_assert(alignof(UMapEditorHandlerComponent) == 0x000010, "Wrong alignment on UMapEditorHandlerComponent");
static_assert(sizeof(UMapEditorHandlerComponent) == 0x000140, "Wrong size on UMapEditorHandlerComponent");
static_assert(offsetof(UMapEditorHandlerComponent, TraceCollisionChannel) == 0x0000B0, "Member 'UMapEditorHandlerComponent::TraceCollisionChannel' has a wrong offset!");
static_assert(offsetof(UMapEditorHandlerComponent, MapDirectory) == 0x0000B8, "Member 'UMapEditorHandlerComponent::MapDirectory' has a wrong offset!");
static_assert(offsetof(UMapEditorHandlerComponent, GizmoClass) == 0x0000C8, "Member 'UMapEditorHandlerComponent::GizmoClass' has a wrong offset!");
static_assert(offsetof(UMapEditorHandlerComponent, ReplicationRate) == 0x0000D0, "Member 'UMapEditorHandlerComponent::ReplicationRate' has a wrong offset!");
static_assert(offsetof(UMapEditorHandlerComponent, CurrentActor) == 0x0000D8, "Member 'UMapEditorHandlerComponent::CurrentActor' has a wrong offset!");
static_assert(offsetof(UMapEditorHandlerComponent, SnapAmount) == 0x000118, "Member 'UMapEditorHandlerComponent::SnapAmount' has a wrong offset!");

// Class Backrooms.MapEditorInterface
// 0x0000 (0x0000 - 0x0000)
class IMapEditorInterface final
{
public:
	void OnDeleted();
	void OnGrabbed();
	void OnMaterialLoaded(const struct FMapEditorItemMaterial& MapEditorItemMaterial);
	void OnRelease();
	void OnScaleChanged(const struct FVector& NewScale);
	void OnUndo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorInterface">();
	}
	static class IMapEditorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapEditorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMapEditorInterface) == 0x000001, "Wrong alignment on IMapEditorInterface");
static_assert(sizeof(IMapEditorInterface) == 0x000001, "Wrong size on IMapEditorInterface");

// Class Backrooms.MapEditorStatics
// 0x0000 (0x0028 - 0x0028)
class UMapEditorStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMap(class AActor* WorldActor);
	static struct FMapEditorItems DeSerializeLevel(const class FString& JsonString, bool* Success);
	static bool DoesMapExist(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName);
	static TArray<class FString> GetMapList(class AActor* WorldActor, const class FString& Directory, bool bCutLevelname, bool bShowAllMaps);
	static class FString GetRealMapName(const class FString& MapName);
	static bool LoadMapFromFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& Extension, class FString* OutString, class FString* FullMapName);
	static class FString RemoveExtension(const class FString& String);
	static bool SaveMapToFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& StringToSave, class FString* FullMapName);
	static class FString SerializeLevel(class AActor* WorldActor, bool* Success);
	static void SetMaterials(const struct FMapEditorItemMaterial& MapEditorItemMaterial);
	static void SpawnMapItems(class AActor* WorldActor, const struct FMapEditorItems& MapItems);
	static void SpawnMapItemsFromJson(class AActor* WorldActor, const class FString& JsonString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEditorStatics">();
	}
	static class UMapEditorStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEditorStatics>();
	}
};
static_assert(alignof(UMapEditorStatics) == 0x000008, "Wrong alignment on UMapEditorStatics");
static_assert(sizeof(UMapEditorStatics) == 0x000028, "Wrong size on UMapEditorStatics");

// Class Backrooms.MotionScannerComponent
// 0x00B0 (0x0160 - 0x00B0)
class UMotionScannerComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FTargetsStruct>& OutTargets, const struct FTelemetryStruct& OutTelemetry)> OnScannerWaveUpdate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMotionComponentType                          ComponentType;                                     // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetStruct                          TargetParameters;                                  // 0x00C8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FScannerStruct                         ScannerParameters;                                 // 0x00E0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           RegisterComponent_Handle;                          // 0x0100(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TryRegister;                                       // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMotionScannerDirector*                 ScannerDirector;                                   // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTargetsStruct>                 TargetsArr;                                        // 0x0118(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         CheckTargetsRate;                                  // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocalController;                                // 0x012C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTargetsStruct>                 VisibleTargetsArr;                                 // 0x0130(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTargetsStruct>                 LastTargetsArr;                                    // 0x0140(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTelemetryStruct                       TelemetryScanner;                                  // 0x0150(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bResetValue;                                       // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWaveEvent();
	void SetNewScanDistance(float setDistance);
	void StartWaveEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionScannerComponent">();
	}
	static class UMotionScannerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionScannerComponent>();
	}
};
static_assert(alignof(UMotionScannerComponent) == 0x000008, "Wrong alignment on UMotionScannerComponent");
static_assert(sizeof(UMotionScannerComponent) == 0x000160, "Wrong size on UMotionScannerComponent");
static_assert(offsetof(UMotionScannerComponent, OnScannerWaveUpdate) == 0x0000B0, "Member 'UMotionScannerComponent::OnScannerWaveUpdate' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, ComponentType) == 0x0000C0, "Member 'UMotionScannerComponent::ComponentType' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, TargetParameters) == 0x0000C8, "Member 'UMotionScannerComponent::TargetParameters' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, ScannerParameters) == 0x0000E0, "Member 'UMotionScannerComponent::ScannerParameters' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, RegisterComponent_Handle) == 0x000100, "Member 'UMotionScannerComponent::RegisterComponent_Handle' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, TryRegister) == 0x000108, "Member 'UMotionScannerComponent::TryRegister' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, ScannerDirector) == 0x000110, "Member 'UMotionScannerComponent::ScannerDirector' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, TargetsArr) == 0x000118, "Member 'UMotionScannerComponent::TargetsArr' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, CheckTargetsRate) == 0x000128, "Member 'UMotionScannerComponent::CheckTargetsRate' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, bIsLocalController) == 0x00012C, "Member 'UMotionScannerComponent::bIsLocalController' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, VisibleTargetsArr) == 0x000130, "Member 'UMotionScannerComponent::VisibleTargetsArr' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, LastTargetsArr) == 0x000140, "Member 'UMotionScannerComponent::LastTargetsArr' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, TelemetryScanner) == 0x000150, "Member 'UMotionScannerComponent::TelemetryScanner' has a wrong offset!");
static_assert(offsetof(UMotionScannerComponent, bResetValue) == 0x000158, "Member 'UMotionScannerComponent::bResetValue' has a wrong offset!");

// Class Backrooms.NoClipVolume
// 0x0000 (0x0258 - 0x0258)
class ANoClipVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoClipVolume">();
	}
	static class ANoClipVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANoClipVolume>();
	}
};
static_assert(alignof(ANoClipVolume) == 0x000008, "Wrong alignment on ANoClipVolume");
static_assert(sizeof(ANoClipVolume) == 0x000258, "Wrong size on ANoClipVolume");

// Class Backrooms.RadarMap
// 0x0098 (0x0398 - 0x0300)
class ARadarMap final : public AInteractablePawn
{
public:
	float                                         CheckMotionRate;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoredActorsArr;                                  // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class URadarPlayerComponent*>          allRadarComponentsArr;                             // 0x0318(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           checkMotion_Handle;                                // 0x0328(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocalController;                                // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RegisterComponent_Handle;                          // 0x0338(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TryRegister;                                       // 0x0340(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMotionScannerDirector*                 ScannerDirector;                                   // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRadarTargetStruct>             TargetsArr;                                        // 0x0350(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         CheckTargetsRate;                                  // 0x0360(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRadarTargetStruct>             VisibleTargetsArr;                                 // 0x0368(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FRadarTargetStruct>             LastTargetsArr;                                    // 0x0378(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTelemetryStruct                       TelemetryScanner;                                  // 0x0388(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bResetValue;                                       // 0x0390(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveMultiply;                                      // 0x0394(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadarMap">();
	}
	static class ARadarMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadarMap>();
	}
};
static_assert(alignof(ARadarMap) == 0x000008, "Wrong alignment on ARadarMap");
static_assert(sizeof(ARadarMap) == 0x000398, "Wrong size on ARadarMap");
static_assert(offsetof(ARadarMap, CheckMotionRate) == 0x000300, "Member 'ARadarMap::CheckMotionRate' has a wrong offset!");
static_assert(offsetof(ARadarMap, IgnoredActorsArr) == 0x000308, "Member 'ARadarMap::IgnoredActorsArr' has a wrong offset!");
static_assert(offsetof(ARadarMap, allRadarComponentsArr) == 0x000318, "Member 'ARadarMap::allRadarComponentsArr' has a wrong offset!");
static_assert(offsetof(ARadarMap, checkMotion_Handle) == 0x000328, "Member 'ARadarMap::checkMotion_Handle' has a wrong offset!");
static_assert(offsetof(ARadarMap, bIsLocalController) == 0x000330, "Member 'ARadarMap::bIsLocalController' has a wrong offset!");
static_assert(offsetof(ARadarMap, RegisterComponent_Handle) == 0x000338, "Member 'ARadarMap::RegisterComponent_Handle' has a wrong offset!");
static_assert(offsetof(ARadarMap, TryRegister) == 0x000340, "Member 'ARadarMap::TryRegister' has a wrong offset!");
static_assert(offsetof(ARadarMap, ScannerDirector) == 0x000348, "Member 'ARadarMap::ScannerDirector' has a wrong offset!");
static_assert(offsetof(ARadarMap, TargetsArr) == 0x000350, "Member 'ARadarMap::TargetsArr' has a wrong offset!");
static_assert(offsetof(ARadarMap, CheckTargetsRate) == 0x000360, "Member 'ARadarMap::CheckTargetsRate' has a wrong offset!");
static_assert(offsetof(ARadarMap, VisibleTargetsArr) == 0x000368, "Member 'ARadarMap::VisibleTargetsArr' has a wrong offset!");
static_assert(offsetof(ARadarMap, LastTargetsArr) == 0x000378, "Member 'ARadarMap::LastTargetsArr' has a wrong offset!");
static_assert(offsetof(ARadarMap, TelemetryScanner) == 0x000388, "Member 'ARadarMap::TelemetryScanner' has a wrong offset!");
static_assert(offsetof(ARadarMap, bResetValue) == 0x000390, "Member 'ARadarMap::bResetValue' has a wrong offset!");
static_assert(offsetof(ARadarMap, WaveMultiply) == 0x000394, "Member 'ARadarMap::WaveMultiply' has a wrong offset!");

// Class Backrooms.RadarPlayerComponent
// 0x00B0 (0x0160 - 0x00B0)
class URadarPlayerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FRadarTargetStruct>& OutTargets, const struct FTelemetryStruct& OutTelemetry)> OnScannerWaveUpdate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMotionComponentType                          ComponentType;                                     // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetStruct                          TargetParameters;                                  // 0x00C8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FScannerStruct                         ScannerParameters;                                 // 0x00E0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           RegisterComponent_Handle;                          // 0x0100(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TryRegister;                                       // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARadarMap*                              RadarMap;                                          // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRadarTargetStruct>             TargetsArr;                                        // 0x0118(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         CheckTargetsRate;                                  // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocalController;                                // 0x012C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRadarTargetStruct>             VisibleTargetsArr;                                 // 0x0130(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FRadarTargetStruct>             LastTargetsArr;                                    // 0x0140(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTelemetryStruct                       TelemetryScanner;                                  // 0x0150(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bResetValue;                                       // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWaveEvent();
	void SetNewScanDistance(float setDistance);
	void StartWaveEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadarPlayerComponent">();
	}
	static class URadarPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadarPlayerComponent>();
	}
};
static_assert(alignof(URadarPlayerComponent) == 0x000008, "Wrong alignment on URadarPlayerComponent");
static_assert(sizeof(URadarPlayerComponent) == 0x000160, "Wrong size on URadarPlayerComponent");
static_assert(offsetof(URadarPlayerComponent, OnScannerWaveUpdate) == 0x0000B0, "Member 'URadarPlayerComponent::OnScannerWaveUpdate' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, ComponentType) == 0x0000C0, "Member 'URadarPlayerComponent::ComponentType' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, TargetParameters) == 0x0000C8, "Member 'URadarPlayerComponent::TargetParameters' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, ScannerParameters) == 0x0000E0, "Member 'URadarPlayerComponent::ScannerParameters' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, RegisterComponent_Handle) == 0x000100, "Member 'URadarPlayerComponent::RegisterComponent_Handle' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, TryRegister) == 0x000108, "Member 'URadarPlayerComponent::TryRegister' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, RadarMap) == 0x000110, "Member 'URadarPlayerComponent::RadarMap' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, TargetsArr) == 0x000118, "Member 'URadarPlayerComponent::TargetsArr' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, CheckTargetsRate) == 0x000128, "Member 'URadarPlayerComponent::CheckTargetsRate' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, bIsLocalController) == 0x00012C, "Member 'URadarPlayerComponent::bIsLocalController' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, VisibleTargetsArr) == 0x000130, "Member 'URadarPlayerComponent::VisibleTargetsArr' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, LastTargetsArr) == 0x000140, "Member 'URadarPlayerComponent::LastTargetsArr' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, TelemetryScanner) == 0x000150, "Member 'URadarPlayerComponent::TelemetryScanner' has a wrong offset!");
static_assert(offsetof(URadarPlayerComponent, bResetValue) == 0x000158, "Member 'URadarPlayerComponent::bResetValue' has a wrong offset!");

// Class Backrooms.SteamManager
// 0x0028 (0x0050 - 0x0028)
class USteamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFancyGameInstance*                     FancyGameInstance;                                 // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamManager">();
	}
	static class USteamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamManager>();
	}
};
static_assert(alignof(USteamManager) == 0x000008, "Wrong alignment on USteamManager");
static_assert(sizeof(USteamManager) == 0x000050, "Wrong size on USteamManager");
static_assert(offsetof(USteamManager, FancyGameInstance) == 0x000048, "Member 'USteamManager::FancyGameInstance' has a wrong offset!");

// Class Backrooms.WalkingVolume
// 0x0000 (0x0258 - 0x0258)
class AWalkingVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalkingVolume">();
	}
	static class AWalkingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWalkingVolume>();
	}
};
static_assert(alignof(AWalkingVolume) == 0x000008, "Wrong alignment on AWalkingVolume");
static_assert(sizeof(AWalkingVolume) == 0x000258, "Wrong size on AWalkingVolume");

}

